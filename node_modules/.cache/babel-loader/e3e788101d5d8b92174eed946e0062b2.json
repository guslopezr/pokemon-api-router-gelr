{"ast":null,"code":"import _classCallCheck from \"/Users/gustavolopez/Documents/Personal GLR/Curso Desafio Latam/MOD REACT 7 ROUTER 2/poke-api router gelr/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/gustavolopez/Documents/Personal GLR/Curso Desafio Latam/MOD REACT 7 ROUTER 2/poke-api router gelr/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/gustavolopez/Documents/Personal GLR/Curso Desafio Latam/MOD REACT 7 ROUTER 2/poke-api router gelr/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _get from \"/Users/gustavolopez/Documents/Personal GLR/Curso Desafio Latam/MOD REACT 7 ROUTER 2/poke-api router gelr/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/gustavolopez/Documents/Personal GLR/Curso Desafio Latam/MOD REACT 7 ROUTER 2/poke-api router gelr/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/gustavolopez/Documents/Personal GLR/Curso Desafio Latam/MOD REACT 7 ROUTER 2/poke-api router gelr/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _assertThisInitialized from \"/Users/gustavolopez/Documents/Personal GLR/Curso Desafio Latam/MOD REACT 7 ROUTER 2/poke-api router gelr/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport { Attribute } from \"../Attribute\";\nimport { AttributeDefinitions } from \"../AttributeDefinitions\";\nimport { DockLocation } from \"../DockLocation\";\nimport { DropInfo } from \"../DropInfo\";\nimport { Orientation } from \"../Orientation\";\nimport { Rect } from \"../Rect\";\nimport { CLASSES } from \"../Types\";\nimport { BorderNode } from \"./BorderNode\";\nimport { Node } from \"./Node\";\nimport { SplitterNode } from \"./SplitterNode\";\nimport { TabSetNode } from \"./TabSetNode\";\nexport var RowNode = /*#__PURE__*/function (_Node) {\n  _inherits(RowNode, _Node);\n\n  /** @internal */\n  function RowNode(model, json) {\n    var _this;\n\n    _classCallCheck(this, RowNode);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(RowNode).call(this, model));\n    _this._dirty = true;\n    _this._drawChildren = [];\n    _this._minHeight = 0;\n    _this._minWidth = 0;\n\n    RowNode._attributeDefinitions.fromJson(json, _this._attributes);\n\n    model._addNode(_assertThisInitialized(_assertThisInitialized(_this)));\n\n    return _this;\n  }\n  /** @internal */\n\n\n  _createClass(RowNode, [{\n    key: \"getWeight\",\n    value: function getWeight() {\n      return this._attributes.weight;\n    }\n  }, {\n    key: \"getWidth\",\n    value: function getWidth() {\n      return this._getAttr(\"width\");\n    }\n  }, {\n    key: \"getHeight\",\n    value: function getHeight() {\n      return this._getAttr(\"height\");\n    }\n    /** @internal */\n\n  }, {\n    key: \"_setWeight\",\n    value: function _setWeight(weight) {\n      this._attributes.weight = weight;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_layout\",\n    value: function _layout(rect, metrics) {\n      _get(_getPrototypeOf(RowNode.prototype), \"_layout\", this).call(this, rect, metrics);\n\n      var pixelSize = this._rect._getSize(this.getOrientation());\n\n      var totalWeight = 0;\n      var fixedPixels = 0;\n      var prefPixels = 0;\n      var totalPrefWeight = 0;\n\n      var drawChildren = this._getDrawChildren();\n\n      var _iterator = _createForOfIteratorHelper(drawChildren),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _child3 = _step.value;\n\n          var _prefSize = _child3._getPrefSize(this.getOrientation());\n\n          if (_child3._isFixed()) {\n            if (_prefSize !== undefined) {\n              fixedPixels += _prefSize;\n            }\n          } else {\n            if (_prefSize === undefined) {\n              totalWeight += _child3.getWeight();\n            } else {\n              prefPixels += _prefSize;\n              totalPrefWeight += _child3.getWeight();\n            }\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      var resizePreferred = false;\n      var availablePixels = pixelSize - fixedPixels - prefPixels;\n\n      if (availablePixels < 0) {\n        availablePixels = pixelSize - fixedPixels;\n        resizePreferred = true;\n        totalWeight += totalPrefWeight;\n      } // assign actual pixel sizes\n\n\n      var totalSizeGiven = 0;\n      var variableSize = 0;\n\n      var _iterator2 = _createForOfIteratorHelper(drawChildren),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _child4 = _step2.value;\n\n          var _prefSize2 = _child4._getPrefSize(this.getOrientation());\n\n          if (_child4._isFixed()) {\n            if (_prefSize2 !== undefined) {\n              _child4._setTempSize(_prefSize2);\n            }\n          } else {\n            if (_prefSize2 == null || resizePreferred) {\n              if (totalWeight === 0) {\n                _child4._setTempSize(0);\n              } else {\n                var _minSize = _child4.getMinSize(this.getOrientation());\n\n                var _size2 = Math.floor(availablePixels * (_child4.getWeight() / totalWeight));\n\n                _child4._setTempSize(Math.max(_minSize, _size2));\n              }\n\n              variableSize += _child4._getTempSize();\n            } else {\n              _child4._setTempSize(_prefSize2);\n            }\n          }\n\n          totalSizeGiven += _child4._getTempSize();\n        } // adjust sizes to exactly fit\n\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      if (variableSize > 0) {\n        while (totalSizeGiven < pixelSize) {\n          var _iterator3 = _createForOfIteratorHelper(drawChildren),\n              _step3;\n\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var child = _step3.value;\n\n              if (!(child instanceof SplitterNode)) {\n                var prefSize = child._getPrefSize(this.getOrientation());\n\n                if (!child._isFixed() && (prefSize === undefined || resizePreferred) && totalSizeGiven < pixelSize) {\n                  child._setTempSize(child._getTempSize() + 1);\n\n                  totalSizeGiven++;\n                }\n              }\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n        } // decrease size using nodes not at there minimum\n\n\n        while (totalSizeGiven > pixelSize) {\n          var changed = false;\n\n          var _iterator4 = _createForOfIteratorHelper(drawChildren),\n              _step4;\n\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var _child = _step4.value;\n\n              if (!(_child instanceof SplitterNode)) {\n                var minSize = _child.getMinSize(this.getOrientation());\n\n                var size = _child._getTempSize();\n\n                if (size > minSize && totalSizeGiven > pixelSize) {\n                  _child._setTempSize(_child._getTempSize() - 1);\n\n                  totalSizeGiven--;\n                  changed = true;\n                }\n              }\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n\n          if (!changed) {\n            // all children are at min values\n            break;\n          }\n        } // if still too big then simply reduce all nodes until fits\n\n\n        while (totalSizeGiven > pixelSize) {\n          var _changed = false;\n\n          var _iterator5 = _createForOfIteratorHelper(drawChildren),\n              _step5;\n\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var _child2 = _step5.value;\n\n              if (!(_child2 instanceof SplitterNode)) {\n                var _size = _child2._getTempSize();\n\n                if (_size > 0 && totalSizeGiven > pixelSize) {\n                  _child2._setTempSize(_child2._getTempSize() - 1);\n\n                  totalSizeGiven--;\n                  _changed = true;\n                }\n              }\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n\n          if (!_changed) {\n            // all children are at 0 values\n            break;\n          }\n        }\n      } // layout children\n\n\n      var p = 0;\n\n      var _iterator6 = _createForOfIteratorHelper(drawChildren),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var _child5 = _step6.value;\n\n          if (this.getOrientation() === Orientation.HORZ) {\n            _child5._layout(new Rect(this._rect.x + p, this._rect.y, _child5._getTempSize(), this._rect.height), metrics);\n          } else {\n            _child5._layout(new Rect(this._rect.x, this._rect.y + p, this._rect.width, _child5._getTempSize()), metrics);\n          }\n\n          p += _child5._getTempSize();\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n\n      return true;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_getSplitterBounds\",\n    value: function _getSplitterBounds(splitterNode) {\n      var useMinSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var pBounds = [0, 0];\n\n      var drawChildren = this._getDrawChildren();\n\n      var p = drawChildren.indexOf(splitterNode);\n      var node1 = drawChildren[p - 1];\n      var node2 = drawChildren[p + 1];\n\n      if (this.getOrientation() === Orientation.HORZ) {\n        var minSize1 = useMinSize ? node1.getMinWidth() : 0;\n        var minSize2 = useMinSize ? node2.getMinWidth() : 0;\n        pBounds[0] = node1.getRect().x + minSize1;\n        pBounds[1] = node2.getRect().getRight() - splitterNode.getWidth() - minSize2;\n      } else {\n        var _minSize2 = useMinSize ? node1.getMinHeight() : 0;\n\n        var _minSize3 = useMinSize ? node2.getMinHeight() : 0;\n\n        pBounds[0] = node1.getRect().y + _minSize2;\n        pBounds[1] = node2.getRect().getBottom() - splitterNode.getHeight() - _minSize3;\n      }\n\n      return pBounds;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_calculateSplit\",\n    value: function _calculateSplit(splitter, splitterPos) {\n      var rtn;\n\n      var drawChildren = this._getDrawChildren();\n\n      var p = drawChildren.indexOf(splitter);\n\n      var pBounds = this._getSplitterBounds(splitter);\n\n      var weightedLength = drawChildren[p - 1].getWeight() + drawChildren[p + 1].getWeight();\n      var pixelWidth1 = Math.max(0, splitterPos - pBounds[0]);\n      var pixelWidth2 = Math.max(0, pBounds[1] - splitterPos);\n\n      if (pixelWidth1 + pixelWidth2 > 0) {\n        var weight1 = pixelWidth1 * weightedLength / (pixelWidth1 + pixelWidth2);\n        var weight2 = pixelWidth2 * weightedLength / (pixelWidth1 + pixelWidth2);\n        rtn = {\n          node1Id: drawChildren[p - 1].getId(),\n          weight1: weight1,\n          pixelWidth1: pixelWidth1,\n          node2Id: drawChildren[p + 1].getId(),\n          weight2: weight2,\n          pixelWidth2: pixelWidth2\n        };\n      }\n\n      return rtn;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_getDrawChildren\",\n    value: function _getDrawChildren() {\n      if (this._dirty) {\n        this._drawChildren = [];\n\n        for (var i = 0; i < this._children.length; i++) {\n          var child = this._children[i];\n\n          if (i !== 0) {\n            var newSplitter = new SplitterNode(this._model);\n\n            newSplitter._setParent(this);\n\n            this._drawChildren.push(newSplitter);\n          }\n\n          this._drawChildren.push(child);\n        }\n\n        this._dirty = false;\n      }\n\n      return this._drawChildren;\n    }\n    /** @internal */\n\n  }, {\n    key: \"getMinSize\",\n    value: function getMinSize(orientation) {\n      if (orientation === Orientation.HORZ) {\n        return this.getMinWidth();\n      } else {\n        return this.getMinHeight();\n      }\n    }\n    /** @internal */\n\n  }, {\n    key: \"getMinWidth\",\n    value: function getMinWidth() {\n      return this._minWidth;\n    }\n    /** @internal */\n\n  }, {\n    key: \"getMinHeight\",\n    value: function getMinHeight() {\n      return this._minHeight;\n    }\n    /** @internal */\n\n  }, {\n    key: \"calcMinSize\",\n    value: function calcMinSize() {\n      this._minHeight = 0;\n      this._minWidth = 0;\n      var first = true;\n\n      var _iterator7 = _createForOfIteratorHelper(this._children),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var child = _step7.value;\n          var c = child;\n\n          if (c instanceof RowNode) {\n            c.calcMinSize();\n          }\n\n          if (this.getOrientation() === Orientation.VERT) {\n            this._minHeight += c.getMinHeight();\n\n            if (!first) {\n              this._minHeight += this._model.getSplitterSize();\n            }\n\n            this._minWidth = Math.max(this._minWidth, c.getMinWidth());\n          } else {\n            this._minWidth += c.getMinWidth();\n\n            if (!first) {\n              this._minWidth += this._model.getSplitterSize();\n            }\n\n            this._minHeight = Math.max(this._minHeight, c.getMinHeight());\n          }\n\n          first = false;\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n    }\n    /** @internal */\n\n  }, {\n    key: \"_tidy\",\n    value: function _tidy() {\n      var i = 0;\n\n      while (i < this._children.length) {\n        var child = this._children[i];\n\n        if (child instanceof RowNode) {\n          child._tidy();\n\n          var childChildren = child.getChildren();\n\n          if (childChildren.length === 0) {\n            this._removeChild(child);\n          } else if (childChildren.length === 1) {\n            // hoist child/children up to this level\n            var subchild = childChildren[0];\n\n            this._removeChild(child);\n\n            if (subchild instanceof RowNode) {\n              var subChildrenTotal = 0;\n              var subChildChildren = subchild.getChildren();\n\n              var _iterator8 = _createForOfIteratorHelper(subChildChildren),\n                  _step8;\n\n              try {\n                for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n                  var ssc = _step8.value;\n                  var _subsubChild = ssc;\n                  subChildrenTotal += _subsubChild.getWeight();\n                }\n              } catch (err) {\n                _iterator8.e(err);\n              } finally {\n                _iterator8.f();\n              }\n\n              for (var j = 0; j < subChildChildren.length; j++) {\n                var subsubChild = subChildChildren[j];\n\n                subsubChild._setWeight(child.getWeight() * subsubChild.getWeight() / subChildrenTotal);\n\n                this._addChild(subsubChild, i + j);\n              }\n            } else {\n              subchild._setWeight(child.getWeight());\n\n              this._addChild(subchild, i);\n            }\n          } else {\n            i++;\n          }\n        } else if (child instanceof TabSetNode && child.getChildren().length === 0) {\n          if (child.isEnableDeleteWhenEmpty()) {\n            this._removeChild(child);\n\n            if (child === this._model.getMaximizedTabset()) {\n              this._model._setMaximizedTabset(undefined);\n            }\n          } else {\n            i++;\n          }\n        } else {\n          i++;\n        }\n      } // add tabset into empty root\n\n\n      if (this === this._model.getRoot() && this._children.length === 0) {\n        var callback = this._model._getOnCreateTabSet();\n\n        var attrs = callback ? callback() : {};\n        attrs = Object.assign(Object.assign({}, attrs), {\n          selected: -1\n        });\n\n        var _child6 = new TabSetNode(this._model, attrs);\n\n        this._model._setActiveTabset(_child6);\n\n        this._addChild(_child6);\n      }\n    }\n    /** @internal */\n\n  }, {\n    key: \"canDrop\",\n    value: function canDrop(dragNode, x, y) {\n      var yy = y - this._rect.y;\n      var xx = x - this._rect.x;\n      var w = this._rect.width;\n      var h = this._rect.height;\n      var margin = 10; // height of edge rect\n\n      var half = 50; // half width of edge rect\n\n      var dropInfo;\n\n      if (this._model.isEnableEdgeDock() && this._parent === undefined) {\n        // _root row\n        if (x < this._rect.x + margin && yy > h / 2 - half && yy < h / 2 + half) {\n          var dockLocation = DockLocation.LEFT;\n          var outlineRect = dockLocation.getDockRect(this._rect);\n          outlineRect.width = outlineRect.width / 2;\n          dropInfo = new DropInfo(this, outlineRect, dockLocation, -1, CLASSES.FLEXLAYOUT__OUTLINE_RECT_EDGE);\n        } else if (x > this._rect.getRight() - margin && yy > h / 2 - half && yy < h / 2 + half) {\n          var _dockLocation = DockLocation.RIGHT;\n\n          var _outlineRect = _dockLocation.getDockRect(this._rect);\n\n          _outlineRect.width = _outlineRect.width / 2;\n          _outlineRect.x += _outlineRect.width;\n          dropInfo = new DropInfo(this, _outlineRect, _dockLocation, -1, CLASSES.FLEXLAYOUT__OUTLINE_RECT_EDGE);\n        } else if (y < this._rect.y + margin && xx > w / 2 - half && xx < w / 2 + half) {\n          var _dockLocation2 = DockLocation.TOP;\n\n          var _outlineRect2 = _dockLocation2.getDockRect(this._rect);\n\n          _outlineRect2.height = _outlineRect2.height / 2;\n          dropInfo = new DropInfo(this, _outlineRect2, _dockLocation2, -1, CLASSES.FLEXLAYOUT__OUTLINE_RECT_EDGE);\n        } else if (y > this._rect.getBottom() - margin && xx > w / 2 - half && xx < w / 2 + half) {\n          var _dockLocation3 = DockLocation.BOTTOM;\n\n          var _outlineRect3 = _dockLocation3.getDockRect(this._rect);\n\n          _outlineRect3.height = _outlineRect3.height / 2;\n          _outlineRect3.y += _outlineRect3.height;\n          dropInfo = new DropInfo(this, _outlineRect3, _dockLocation3, -1, CLASSES.FLEXLAYOUT__OUTLINE_RECT_EDGE);\n        }\n\n        if (dropInfo !== undefined) {\n          if (!dragNode._canDockInto(dragNode, dropInfo)) {\n            return undefined;\n          }\n        }\n      }\n\n      return dropInfo;\n    }\n    /** @internal */\n\n  }, {\n    key: \"drop\",\n    value: function drop(dragNode, location, index) {\n      var dockLocation = location;\n      var parent = dragNode.getParent();\n\n      if (parent) {\n        parent._removeChild(dragNode);\n      }\n\n      if (parent !== undefined && parent.getType() === TabSetNode.TYPE) {\n        parent._setSelected(0);\n      }\n\n      if (parent !== undefined && parent.getType() === BorderNode.TYPE) {\n        parent._setSelected(-1);\n      }\n\n      var tabSet;\n\n      if (dragNode instanceof TabSetNode) {\n        tabSet = dragNode;\n      } else {\n        var callback = this._model._getOnCreateTabSet();\n\n        tabSet = new TabSetNode(this._model, callback ? callback(dragNode) : {});\n\n        tabSet._addChild(dragNode);\n      }\n\n      var size = this._children.reduce(function (sum, child) {\n        return sum + child.getWeight();\n      }, 0);\n\n      if (size === 0) {\n        size = 100;\n      }\n\n      tabSet._setWeight(size / 3);\n\n      var horz = !this._model.isRootOrientationVertical();\n\n      if (horz && dockLocation === DockLocation.LEFT || !horz && dockLocation === DockLocation.TOP) {\n        this._addChild(tabSet, 0);\n      } else if (horz && dockLocation === DockLocation.RIGHT || !horz && dockLocation === DockLocation.BOTTOM) {\n        this._addChild(tabSet);\n      } else if (horz && dockLocation === DockLocation.TOP || !horz && dockLocation === DockLocation.LEFT) {\n        var vrow = new RowNode(this._model, {});\n        var hrow = new RowNode(this._model, {});\n\n        hrow._setWeight(75);\n\n        tabSet._setWeight(25);\n\n        var _iterator9 = _createForOfIteratorHelper(this._children),\n            _step9;\n\n        try {\n          for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n            var child = _step9.value;\n\n            hrow._addChild(child);\n          }\n        } catch (err) {\n          _iterator9.e(err);\n        } finally {\n          _iterator9.f();\n        }\n\n        this._removeAll();\n\n        vrow._addChild(tabSet);\n\n        vrow._addChild(hrow);\n\n        this._addChild(vrow);\n      } else if (horz && dockLocation === DockLocation.BOTTOM || !horz && dockLocation === DockLocation.RIGHT) {\n        var _vrow = new RowNode(this._model, {});\n\n        var _hrow = new RowNode(this._model, {});\n\n        _hrow._setWeight(75);\n\n        tabSet._setWeight(25);\n\n        var _iterator10 = _createForOfIteratorHelper(this._children),\n            _step10;\n\n        try {\n          for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n            var _child7 = _step10.value;\n\n            _hrow._addChild(_child7);\n          }\n        } catch (err) {\n          _iterator10.e(err);\n        } finally {\n          _iterator10.f();\n        }\n\n        this._removeAll();\n\n        _vrow._addChild(_hrow);\n\n        _vrow._addChild(tabSet);\n\n        this._addChild(_vrow);\n      }\n\n      this._model._setActiveTabset(tabSet);\n\n      this._model._tidy();\n    }\n  }, {\n    key: \"toJson\",\n    value: function toJson() {\n      var json = {};\n\n      RowNode._attributeDefinitions.toJson(json, this._attributes);\n\n      json.children = [];\n\n      var _iterator11 = _createForOfIteratorHelper(this._children),\n          _step11;\n\n      try {\n        for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n          var child = _step11.value;\n          json.children.push(child.toJson());\n        }\n      } catch (err) {\n        _iterator11.e(err);\n      } finally {\n        _iterator11.f();\n      }\n\n      return json;\n    }\n  }, {\n    key: \"isEnableDrop\",\n    value: function isEnableDrop() {\n      return true;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_getPrefSize\",\n    value: function _getPrefSize(orientation) {\n      var prefSize = this.getWidth();\n\n      if (orientation === Orientation.VERT) {\n        prefSize = this.getHeight();\n      }\n\n      return prefSize;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_getAttributeDefinitions\",\n    value: function _getAttributeDefinitions() {\n      return RowNode._attributeDefinitions;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_updateAttrs\",\n    value: function _updateAttrs(json) {\n      RowNode._attributeDefinitions.update(json, this._attributes);\n    }\n    /** @internal */\n\n  }], [{\n    key: \"_fromJson\",\n    value: function _fromJson(json, model) {\n      var newLayoutNode = new RowNode(model, json);\n\n      if (json.children != null) {\n        var _iterator12 = _createForOfIteratorHelper(json.children),\n            _step12;\n\n        try {\n          for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n            var jsonChild = _step12.value;\n\n            if (jsonChild.type === TabSetNode.TYPE) {\n              var child = TabSetNode._fromJson(jsonChild, model);\n\n              newLayoutNode._addChild(child);\n            } else {\n              var _child8 = RowNode._fromJson(jsonChild, model);\n\n              newLayoutNode._addChild(_child8);\n            }\n          }\n        } catch (err) {\n          _iterator12.e(err);\n        } finally {\n          _iterator12.f();\n        }\n      }\n\n      return newLayoutNode;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_createAttributeDefinitions\",\n    value: function _createAttributeDefinitions() {\n      var attributeDefinitions = new AttributeDefinitions();\n      attributeDefinitions.add(\"type\", RowNode.TYPE, true).setType(Attribute.STRING).setFixed();\n      attributeDefinitions.add(\"id\", undefined).setType(Attribute.STRING);\n      attributeDefinitions.add(\"weight\", 100).setType(Attribute.NUMBER);\n      attributeDefinitions.add(\"width\", undefined).setType(Attribute.NUMBER);\n      attributeDefinitions.add(\"height\", undefined).setType(Attribute.NUMBER);\n      return attributeDefinitions;\n    }\n  }, {\n    key: \"getAttributeDefinitions\",\n    value: function getAttributeDefinitions() {\n      return RowNode._attributeDefinitions;\n    }\n  }]);\n\n  return RowNode;\n}(Node);\nRowNode.TYPE = \"row\";\n/** @internal */\n\nRowNode._attributeDefinitions = RowNode._createAttributeDefinitions();","map":null,"metadata":{},"sourceType":"module"}