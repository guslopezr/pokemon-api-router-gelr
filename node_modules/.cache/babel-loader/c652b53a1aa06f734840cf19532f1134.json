{"ast":null,"code":"import _classCallCheck from \"/Users/gustavolopez/Documents/Personal GLR/Curso Desafio Latam/MOD REACT 7 ROUTER 2/poke-api router gelr/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/gustavolopez/Documents/Personal GLR/Curso Desafio Latam/MOD REACT 7 ROUTER 2/poke-api router gelr/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/gustavolopez/Documents/Personal GLR/Curso Desafio Latam/MOD REACT 7 ROUTER 2/poke-api router gelr/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/gustavolopez/Documents/Personal GLR/Curso Desafio Latam/MOD REACT 7 ROUTER 2/poke-api router gelr/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/gustavolopez/Documents/Personal GLR/Curso Desafio Latam/MOD REACT 7 ROUTER 2/poke-api router gelr/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _assertThisInitialized from \"/Users/gustavolopez/Documents/Personal GLR/Curso Desafio Latam/MOD REACT 7 ROUTER 2/poke-api router gelr/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport * as React from \"react\";\nimport { createPortal } from \"react-dom\";\nimport { DockLocation } from \"../DockLocation\";\nimport { DragDrop } from \"../DragDrop\";\nimport { Actions } from \"../model/Actions\";\nimport { BorderNode } from \"../model/BorderNode\";\nimport { SplitterNode } from \"../model/SplitterNode\";\nimport { TabNode } from \"../model/TabNode\";\nimport { TabSetNode } from \"../model/TabSetNode\";\nimport { Rect } from \"../Rect\";\nimport { CLASSES } from \"../Types\";\nimport { BorderTabSet } from \"./BorderTabSet\";\nimport { Splitter } from \"./Splitter\";\nimport { Tab } from \"./Tab\";\nimport { TabSet } from \"./TabSet\";\nimport { FloatingWindow } from \"./FloatingWindow\";\nimport { FloatingWindowTab } from \"./FloatingWindowTab\";\nimport { TabFloating } from \"./TabFloating\";\nimport { Orientation } from \"../Orientation\";\nimport { CloseIcon, MaximizeIcon, OverflowIcon, PopoutIcon, RestoreIcon } from \"./Icons\";\nimport { TabButtonStamp } from \"./TabButtonStamp\";\nvar defaultIcons = {\n  close: React.createElement(CloseIcon, null),\n  closeTabset: React.createElement(CloseIcon, null),\n  popout: React.createElement(PopoutIcon, null),\n  maximize: React.createElement(MaximizeIcon, null),\n  restore: React.createElement(RestoreIcon, null),\n  more: React.createElement(OverflowIcon, null)\n}; // Popout windows work in latest browsers based on webkit (Chrome, Opera, Safari, latest Edge) and Firefox. They do\n// not work on any version if IE or the original Edge browser\n// Assume any recent desktop browser not IE or original Edge will work\n\n/** @internal */\n// @ts-ignore\n\nvar isIEorEdge = typeof window !== \"undefined\" && (window.document.documentMode || /Edge\\//.test(window.navigator.userAgent));\n/** @internal */\n\nvar isDesktop = typeof window !== \"undefined\" && window.matchMedia && window.matchMedia(\"(hover: hover) and (pointer: fine)\").matches;\n/** @internal */\n\nvar defaultSupportsPopout = isDesktop && !isIEorEdge;\n/**\n * A React component that hosts a multi-tabbed layout\n */\n\nexport var Layout = /*#__PURE__*/function (_React$Component) {\n  _inherits(Layout, _React$Component);\n\n  function Layout(props) {\n    var _this;\n\n    _classCallCheck(this, Layout);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Layout).call(this, props));\n    /** @internal */\n\n    _this.firstMove = false;\n    /** @internal */\n\n    _this.dragRectRendered = true;\n    /** @internal */\n\n    _this.dragDivText = undefined;\n    /** @internal */\n\n    _this.edgeRectLength = 100;\n    /** @internal */\n\n    _this.edgeRectWidth = 10;\n    /** @internal */\n\n    _this.onModelChange = function () {\n      _this.forceUpdate();\n\n      if (_this.props.onModelChange) {\n        _this.props.onModelChange(_this.props.model);\n      }\n    };\n    /** @internal */\n\n\n    _this.updateRect = function () {\n      var domRect = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.getDomRect();\n      var rect = new Rect(0, 0, domRect.width, domRect.height);\n\n      if (!rect.equals(_this.state.rect) && rect.width !== 0 && rect.height !== 0) {\n        _this.setState({\n          rect: rect\n        });\n      }\n    };\n    /** @internal */\n\n\n    _this.updateLayoutMetrics = function () {\n      if (_this.findHeaderBarSizeRef.current) {\n        var headerBarSize = _this.findHeaderBarSizeRef.current.getBoundingClientRect().height;\n\n        if (headerBarSize !== _this.state.calculatedHeaderBarSize) {\n          _this.setState({\n            calculatedHeaderBarSize: headerBarSize\n          });\n        }\n      }\n\n      if (_this.findTabBarSizeRef.current) {\n        var tabBarSize = _this.findTabBarSizeRef.current.getBoundingClientRect().height;\n\n        if (tabBarSize !== _this.state.calculatedTabBarSize) {\n          _this.setState({\n            calculatedTabBarSize: tabBarSize\n          });\n        }\n      }\n\n      if (_this.findBorderBarSizeRef.current) {\n        var borderBarSize = _this.findBorderBarSizeRef.current.getBoundingClientRect().height;\n\n        if (borderBarSize !== _this.state.calculatedBorderBarSize) {\n          _this.setState({\n            calculatedBorderBarSize: borderBarSize\n          });\n        }\n      }\n    };\n    /** @internal */\n\n\n    _this.getClassName = function (defaultClassName) {\n      if (_this.props.classNameMapper === undefined) {\n        return defaultClassName;\n      } else {\n        return _this.props.classNameMapper(defaultClassName);\n      }\n    };\n    /** @internal */\n\n\n    _this.onCloseWindow = function (id) {\n      _this.doAction(Actions.unFloatTab(id));\n\n      try {\n        _this.props.model.getNodeById(id)._setWindow(undefined);\n      } catch (e) {// catch incase it was a model change\n      }\n    };\n    /** @internal */\n\n\n    _this.onSetWindow = function (id, window) {\n      _this.props.model.getNodeById(id)._setWindow(window);\n    };\n    /** @internal */\n\n\n    _this.onCancelAdd = function () {\n      var _a, _b;\n\n      var rootdiv = _this.selfRef.current;\n      rootdiv.removeChild(_this.dragDiv);\n      _this.dragDiv = undefined;\n\n      _this.hidePortal();\n\n      if (_this.fnNewNodeDropped != null) {\n        _this.fnNewNodeDropped();\n\n        _this.fnNewNodeDropped = undefined;\n      }\n\n      try {\n        (_b = (_a = _this.customDrop) === null || _a === void 0 ? void 0 : _a.invalidated) === null || _b === void 0 ? void 0 : _b.call(_a);\n      } catch (e) {\n        console.error(e);\n      }\n\n      DragDrop.instance.hideGlass();\n      _this.newTabJson = undefined;\n      _this.customDrop = undefined;\n    };\n    /** @internal */\n\n\n    _this.onCancelDrag = function (wasDragging) {\n      var _a, _b;\n\n      if (wasDragging) {\n        var rootdiv = _this.selfRef.current;\n\n        try {\n          rootdiv.removeChild(_this.outlineDiv);\n        } catch (e) {}\n\n        try {\n          rootdiv.removeChild(_this.dragDiv);\n        } catch (e) {}\n\n        _this.dragDiv = undefined;\n\n        _this.hidePortal();\n\n        _this.setState({\n          showEdges: false\n        });\n\n        if (_this.fnNewNodeDropped != null) {\n          _this.fnNewNodeDropped();\n\n          _this.fnNewNodeDropped = undefined;\n        }\n\n        try {\n          (_b = (_a = _this.customDrop) === null || _a === void 0 ? void 0 : _a.invalidated) === null || _b === void 0 ? void 0 : _b.call(_a);\n        } catch (e) {\n          console.error(e);\n        }\n\n        DragDrop.instance.hideGlass();\n        _this.newTabJson = undefined;\n        _this.customDrop = undefined;\n      }\n\n      _this.setState({\n        showHiddenBorder: DockLocation.CENTER\n      });\n    };\n    /** @internal */\n\n\n    _this.onDragDivMouseDown = function (event) {\n      event.preventDefault();\n\n      _this.dragStart(event, _this.dragDivText, TabNode._fromJson(_this.newTabJson, _this.props.model, false), true, undefined, undefined);\n    };\n    /** @internal */\n\n\n    _this.dragStart = function (event, dragDivText, node, allowDrag, onClick, onDoubleClick) {\n      if (!allowDrag) {\n        DragDrop.instance.startDrag(event, undefined, undefined, undefined, undefined, onClick, onDoubleClick, _this.currentDocument, _this.selfRef.current);\n      } else {\n        _this.dragNode = node;\n        _this.dragDivText = dragDivText;\n        DragDrop.instance.startDrag(event, _this.onDragStart, _this.onDragMove, _this.onDragEnd, _this.onCancelDrag, onClick, onDoubleClick, _this.currentDocument, _this.selfRef.current);\n      }\n    };\n    /** @internal */\n\n\n    _this.dragRectRender = function (text, node, json, _onRendered) {\n      var content;\n\n      if (text !== undefined) {\n        content = React.createElement(\"div\", {\n          style: {\n            whiteSpace: \"pre\"\n          }\n        }, text.replace(\"<br>\", \"\\n\"));\n      } else {\n        if (node && node instanceof TabNode) {\n          content = React.createElement(TabButtonStamp, {\n            node: node,\n            layout: _assertThisInitialized(_assertThisInitialized(_this)),\n            iconFactory: _this.props.iconFactory,\n            titleFactory: _this.props.titleFactory\n          });\n        }\n      }\n\n      if (_this.props.onRenderDragRect !== undefined) {\n        var customContent = _this.props.onRenderDragRect(content, node, json);\n\n        if (customContent !== undefined) {\n          content = customContent;\n        }\n      } // hide div until the render is complete\n\n\n      _this.dragDiv.style.visibility = \"hidden\";\n      _this.dragRectRendered = false;\n\n      _this.showPortal(React.createElement(DragRectRenderWrapper // wait for it to be rendered\n      , {\n        // wait for it to be rendered\n        onRendered: function onRendered() {\n          _this.dragRectRendered = true;\n          _onRendered === null || _onRendered === void 0 ? void 0 : _onRendered();\n        }\n      }, content), _this.dragDiv);\n    };\n    /** @internal */\n\n\n    _this.showPortal = function (control, element) {\n      var portal = createPortal(control, element);\n\n      _this.setState({\n        portal: portal\n      });\n    };\n    /** @internal */\n\n\n    _this.hidePortal = function () {\n      _this.setState({\n        portal: undefined\n      });\n    };\n    /** @internal */\n\n\n    _this.onDragStart = function () {\n      _this.dropInfo = undefined;\n      _this.customDrop = undefined;\n      var rootdiv = _this.selfRef.current;\n      _this.outlineDiv = _this.currentDocument.createElement(\"div\");\n      _this.outlineDiv.className = _this.getClassName(CLASSES.FLEXLAYOUT__OUTLINE_RECT);\n      _this.outlineDiv.style.visibility = \"hidden\";\n      rootdiv.appendChild(_this.outlineDiv);\n\n      if (_this.dragDiv == null) {\n        _this.dragDiv = _this.currentDocument.createElement(\"div\");\n        _this.dragDiv.className = _this.getClassName(CLASSES.FLEXLAYOUT__DRAG_RECT);\n\n        _this.dragDiv.setAttribute(\"data-layout-path\", \"/drag-rectangle\");\n\n        _this.dragRectRender(_this.dragDivText, _this.dragNode, _this.newTabJson);\n\n        rootdiv.appendChild(_this.dragDiv);\n      } // add edge indicators\n\n\n      if (_this.props.model.getMaximizedTabset() === undefined) {\n        _this.setState({\n          showEdges: true\n        });\n      }\n\n      if (_this.dragNode !== undefined && _this.dragNode instanceof TabNode && _this.dragNode.getTabRect() !== undefined) {\n        _this.dragNode.getTabRect().positionElement(_this.outlineDiv);\n      }\n\n      _this.firstMove = true;\n      return true;\n    };\n    /** @internal */\n\n\n    _this.onDragMove = function (event) {\n      if (_this.firstMove === false) {\n        var speed = _this.props.model._getAttribute(\"tabDragSpeed\");\n\n        _this.outlineDiv.style.transition = \"top \".concat(speed, \"s, left \").concat(speed, \"s, width \").concat(speed, \"s, height \").concat(speed, \"s\");\n      }\n\n      _this.firstMove = false;\n\n      var clientRect = _this.selfRef.current.getBoundingClientRect();\n\n      var pos = {\n        x: event.clientX - clientRect.left,\n        y: event.clientY - clientRect.top\n      };\n\n      _this.checkForBorderToShow(pos.x, pos.y); // keep it between left & right\n\n\n      var dragRect = _this.dragDiv.getBoundingClientRect();\n\n      var newLeft = pos.x - dragRect.width / 2;\n\n      if (newLeft + dragRect.width > clientRect.width) {\n        newLeft = clientRect.width - dragRect.width;\n      }\n\n      newLeft = Math.max(0, newLeft);\n      _this.dragDiv.style.left = newLeft + \"px\";\n      _this.dragDiv.style.top = pos.y + 5 + \"px\";\n\n      if (_this.dragRectRendered && _this.dragDiv.style.visibility === \"hidden\") {\n        // make visible once the drag rect has been rendered\n        _this.dragDiv.style.visibility = \"visible\";\n      }\n\n      var dropInfo = _this.props.model._findDropTargetNode(_this.dragNode, pos.x, pos.y);\n\n      if (dropInfo) {\n        if (_this.props.onTabDrag) {\n          _this.handleCustomTabDrag(dropInfo, pos, event);\n        } else {\n          _this.dropInfo = dropInfo;\n          _this.outlineDiv.className = _this.getClassName(dropInfo.className);\n          dropInfo.rect.positionElement(_this.outlineDiv);\n          _this.outlineDiv.style.visibility = \"visible\";\n        }\n      }\n    };\n    /** @internal */\n\n\n    _this.onDragEnd = function (event) {\n      var rootdiv = _this.selfRef.current;\n      rootdiv.removeChild(_this.outlineDiv);\n      rootdiv.removeChild(_this.dragDiv);\n      _this.dragDiv = undefined;\n\n      _this.hidePortal();\n\n      _this.setState({\n        showEdges: false\n      });\n\n      DragDrop.instance.hideGlass();\n\n      if (_this.dropInfo) {\n        if (_this.customDrop) {\n          _this.newTabJson = undefined;\n\n          try {\n            var _this$customDrop = _this.customDrop,\n                callback = _this$customDrop.callback,\n                dragging = _this$customDrop.dragging,\n                over = _this$customDrop.over,\n                x = _this$customDrop.x,\n                y = _this$customDrop.y,\n                location = _this$customDrop.location;\n            callback(dragging, over, x, y, location);\n\n            if (_this.fnNewNodeDropped != null) {\n              _this.fnNewNodeDropped();\n\n              _this.fnNewNodeDropped = undefined;\n            }\n          } catch (e) {\n            console.error(e);\n          }\n        } else if (_this.newTabJson !== undefined) {\n          var newNode = _this.doAction(Actions.addNode(_this.newTabJson, _this.dropInfo.node.getId(), _this.dropInfo.location, _this.dropInfo.index));\n\n          if (_this.fnNewNodeDropped != null) {\n            _this.fnNewNodeDropped(newNode, event);\n\n            _this.fnNewNodeDropped = undefined;\n          }\n\n          _this.newTabJson = undefined;\n        } else if (_this.dragNode !== undefined) {\n          _this.doAction(Actions.moveNode(_this.dragNode.getId(), _this.dropInfo.node.getId(), _this.dropInfo.location, _this.dropInfo.index));\n        }\n      }\n\n      _this.setState({\n        showHiddenBorder: DockLocation.CENTER\n      });\n    };\n\n    _this.props.model._setChangeListener(_this.onModelChange);\n\n    _this.tabIds = [];\n    _this.selfRef = React.createRef();\n    _this.findHeaderBarSizeRef = React.createRef();\n    _this.findTabBarSizeRef = React.createRef();\n    _this.findBorderBarSizeRef = React.createRef();\n    _this.supportsPopout = props.supportsPopout !== undefined ? props.supportsPopout : defaultSupportsPopout;\n    _this.popoutURL = props.popoutURL ? props.popoutURL : \"popout.html\";\n    _this.icons = Object.assign(Object.assign({}, defaultIcons), props.icons);\n    _this.state = {\n      rect: new Rect(0, 0, 0, 0),\n      calculatedHeaderBarSize: 25,\n      calculatedTabBarSize: 26,\n      calculatedBorderBarSize: 30,\n      editingTab: undefined,\n      showHiddenBorder: DockLocation.CENTER,\n      showEdges: false\n    };\n    _this.onDragEnter = _this.onDragEnter.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    return _this;\n  }\n  /** @internal */\n\n\n  _createClass(Layout, [{\n    key: \"styleFont\",\n    value: function styleFont(style) {\n      if (this.props.font) {\n        if (this.selfRef.current) {\n          if (this.props.font.size) {\n            this.selfRef.current.style.setProperty(\"--font-size\", this.props.font.size);\n          }\n\n          if (this.props.font.family) {\n            this.selfRef.current.style.setProperty(\"--font-family\", this.props.font.family);\n          }\n        }\n\n        if (this.props.font.style) {\n          style.fontStyle = this.props.font.style;\n        }\n\n        if (this.props.font.weight) {\n          style.fontWeight = this.props.font.weight;\n        }\n      }\n\n      return style;\n    }\n    /** @internal */\n\n  }, {\n    key: \"doAction\",\n    value: function doAction(action) {\n      if (this.props.onAction !== undefined) {\n        var outcome = this.props.onAction(action);\n\n        if (outcome !== undefined) {\n          return this.props.model.doAction(outcome);\n        }\n\n        return undefined;\n      } else {\n        return this.props.model.doAction(action);\n      }\n    }\n    /** @internal */\n\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this2 = this;\n\n      this.updateRect();\n      this.updateLayoutMetrics(); // need to re-render if size changes\n\n      this.currentDocument = this.selfRef.current.ownerDocument;\n      this.currentWindow = this.currentDocument.defaultView;\n      this.resizeObserver = new ResizeObserver(function (entries) {\n        _this2.updateRect(entries[0].contentRect);\n      });\n      this.resizeObserver.observe(this.selfRef.current);\n    }\n    /** @internal */\n\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate() {\n      this.updateLayoutMetrics();\n\n      if (this.props.model !== this.previousModel) {\n        if (this.previousModel !== undefined) {\n          this.previousModel._setChangeListener(undefined); // stop listening to old model\n\n        }\n\n        this.props.model._setChangeListener(this.onModelChange);\n\n        this.previousModel = this.props.model;\n      } // console.log(\"Layout time: \" + this.layoutTime + \"ms Render time: \" + (Date.now() - this.start) + \"ms\");\n\n    }\n    /** @internal */\n\n  }, {\n    key: \"getCurrentDocument\",\n    value: function getCurrentDocument() {\n      return this.currentDocument;\n    }\n    /** @internal */\n\n  }, {\n    key: \"getDomRect\",\n    value: function getDomRect() {\n      return this.selfRef.current.getBoundingClientRect();\n    }\n    /** @internal */\n\n  }, {\n    key: \"getRootDiv\",\n    value: function getRootDiv() {\n      return this.selfRef.current;\n    }\n    /** @internal */\n\n  }, {\n    key: \"isSupportsPopout\",\n    value: function isSupportsPopout() {\n      return this.supportsPopout;\n    }\n    /** @internal */\n\n  }, {\n    key: \"isRealtimeResize\",\n    value: function isRealtimeResize() {\n      var _a;\n\n      return (_a = this.props.realtimeResize) !== null && _a !== void 0 ? _a : false;\n    }\n    /** @internal */\n\n  }, {\n    key: \"onTabDrag\",\n    value: function onTabDrag() {\n      var _b2;\n\n      var _a, _b;\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return (_b = (_a = this.props).onTabDrag) === null || _b === void 0 ? void 0 : (_b2 = _b).call.apply(_b2, [_a].concat(args));\n    }\n    /** @internal */\n\n  }, {\n    key: \"getPopoutURL\",\n    value: function getPopoutURL() {\n      return this.popoutURL;\n    }\n    /** @internal */\n\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      var _a;\n\n      (_a = this.resizeObserver) === null || _a === void 0 ? void 0 : _a.unobserve(this.selfRef.current);\n    }\n    /** @internal */\n\n  }, {\n    key: \"setEditingTab\",\n    value: function setEditingTab(tabNode) {\n      this.setState({\n        editingTab: tabNode\n      });\n    }\n    /** @internal */\n\n  }, {\n    key: \"getEditingTab\",\n    value: function getEditingTab() {\n      return this.state.editingTab;\n    }\n    /** @internal */\n\n  }, {\n    key: \"render\",\n    value: function render() {\n      // first render will be used to find the size (via selfRef)\n      if (!this.selfRef.current) {\n        return React.createElement(\"div\", {\n          ref: this.selfRef,\n          className: this.getClassName(CLASSES.FLEXLAYOUT__LAYOUT)\n        }, this.metricsElements());\n      }\n\n      this.props.model._setPointerFine(window && window.matchMedia && window.matchMedia(\"(pointer: fine)\").matches); // this.start = Date.now();\n\n\n      var borderComponents = [];\n      var tabSetComponents = [];\n      var floatingWindows = [];\n      var tabComponents = {};\n      var splitterComponents = [];\n      var metrics = {\n        headerBarSize: this.state.calculatedHeaderBarSize,\n        tabBarSize: this.state.calculatedTabBarSize,\n        borderBarSize: this.state.calculatedBorderBarSize\n      };\n\n      this.props.model._setShowHiddenBorder(this.state.showHiddenBorder);\n\n      this.centerRect = this.props.model._layout(this.state.rect, metrics);\n      this.renderBorder(this.props.model.getBorderSet(), borderComponents, tabComponents, floatingWindows, splitterComponents);\n      this.renderChildren(\"\", this.props.model.getRoot(), tabSetComponents, tabComponents, floatingWindows, splitterComponents);\n      var nextTopIds = [];\n      var nextTopIdsMap = {}; // Keep any previous tabs in the same DOM order as before, removing any that have been deleted\n\n      var _iterator = _createForOfIteratorHelper(this.tabIds),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _t = _step.value;\n\n          if (tabComponents[_t]) {\n            nextTopIds.push(_t);\n            nextTopIdsMap[_t] = _t;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      this.tabIds = nextTopIds; // Add tabs that have been added to the DOM\n\n      for (var _i = 0, _Object$keys = Object.keys(tabComponents); _i < _Object$keys.length; _i++) {\n        var t = _Object$keys[_i];\n\n        if (!nextTopIdsMap[t]) {\n          this.tabIds.push(t);\n        }\n      }\n\n      var edges = [];\n\n      if (this.state.showEdges) {\n        var r = this.centerRect;\n        var length = this.edgeRectLength;\n        var width = this.edgeRectWidth;\n        var offset = this.edgeRectLength / 2;\n        var className = this.getClassName(CLASSES.FLEXLAYOUT__EDGE_RECT);\n        var radius = 50;\n        edges.push(React.createElement(\"div\", {\n          key: \"North\",\n          style: {\n            top: r.y,\n            left: r.x + r.width / 2 - offset,\n            width: length,\n            height: width,\n            borderBottomLeftRadius: radius,\n            borderBottomRightRadius: radius\n          },\n          className: className\n        }));\n        edges.push(React.createElement(\"div\", {\n          key: \"West\",\n          style: {\n            top: r.y + r.height / 2 - offset,\n            left: r.x,\n            width: width,\n            height: length,\n            borderTopRightRadius: radius,\n            borderBottomRightRadius: radius\n          },\n          className: className\n        }));\n        edges.push(React.createElement(\"div\", {\n          key: \"South\",\n          style: {\n            top: r.y + r.height - width,\n            left: r.x + r.width / 2 - offset,\n            width: length,\n            height: width,\n            borderTopLeftRadius: radius,\n            borderTopRightRadius: radius\n          },\n          className: className\n        }));\n        edges.push(React.createElement(\"div\", {\n          key: \"East\",\n          style: {\n            top: r.y + r.height / 2 - offset,\n            left: r.x + r.width - width,\n            width: width,\n            height: length,\n            borderTopLeftRadius: radius,\n            borderBottomLeftRadius: radius\n          },\n          className: className\n        }));\n      } // this.layoutTime = (Date.now() - this.start);\n\n\n      return React.createElement(\"div\", {\n        ref: this.selfRef,\n        className: this.getClassName(CLASSES.FLEXLAYOUT__LAYOUT),\n        onDragEnter: this.props.onExternalDrag ? this.onDragEnter : undefined\n      }, tabSetComponents, this.tabIds.map(function (t) {\n        return tabComponents[t];\n      }), borderComponents, splitterComponents, edges, floatingWindows, this.metricsElements(), this.state.portal);\n    }\n    /** @internal */\n\n  }, {\n    key: \"metricsElements\",\n    value: function metricsElements() {\n      // used to measure the tab and border tab sizes\n      var fontStyle = this.styleFont({\n        visibility: \"hidden\"\n      });\n      return React.createElement(React.Fragment, null, React.createElement(\"div\", {\n        key: \"findHeaderBarSize\",\n        ref: this.findHeaderBarSizeRef,\n        style: fontStyle,\n        className: this.getClassName(CLASSES.FLEXLAYOUT__TABSET_HEADER_SIZER)\n      }, \"FindHeaderBarSize\"), React.createElement(\"div\", {\n        key: \"findTabBarSize\",\n        ref: this.findTabBarSizeRef,\n        style: fontStyle,\n        className: this.getClassName(CLASSES.FLEXLAYOUT__TABSET_SIZER)\n      }, \"FindTabBarSize\"), React.createElement(\"div\", {\n        key: \"findBorderBarSize\",\n        ref: this.findBorderBarSizeRef,\n        style: fontStyle,\n        className: this.getClassName(CLASSES.FLEXLAYOUT__BORDER_SIZER)\n      }, \"FindBorderBarSize\"));\n    }\n    /** @internal */\n\n  }, {\n    key: \"renderBorder\",\n    value: function renderBorder(borderSet, borderComponents, tabComponents, floatingWindows, splitterComponents) {\n      var _iterator2 = _createForOfIteratorHelper(borderSet.getBorders()),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var border = _step2.value;\n          var borderPath = \"/border/\".concat(border.getLocation().getName());\n\n          if (border.isShowing()) {\n            borderComponents.push(React.createElement(BorderTabSet, {\n              key: \"border_\".concat(border.getLocation().getName()),\n              path: borderPath,\n              border: border,\n              layout: this,\n              iconFactory: this.props.iconFactory,\n              titleFactory: this.props.titleFactory,\n              icons: this.icons\n            }));\n\n            var drawChildren = border._getDrawChildren();\n\n            var i = 0;\n            var tabCount = 0;\n\n            var _iterator3 = _createForOfIteratorHelper(drawChildren),\n                _step3;\n\n            try {\n              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                var child = _step3.value;\n\n                if (child instanceof SplitterNode) {\n                  var path = borderPath + \"/s\";\n                  splitterComponents.push(React.createElement(Splitter, {\n                    key: child.getId(),\n                    layout: this,\n                    node: child,\n                    path: path\n                  }));\n                } else if (child instanceof TabNode) {\n                  var _path = borderPath + \"/t\" + tabCount++;\n\n                  if (this.supportsPopout && child.isFloating()) {\n                    var rect = this._getScreenRect(child);\n\n                    floatingWindows.push(React.createElement(FloatingWindow, {\n                      key: child.getId(),\n                      url: this.popoutURL,\n                      rect: rect,\n                      title: child.getName(),\n                      id: child.getId(),\n                      onSetWindow: this.onSetWindow,\n                      onCloseWindow: this.onCloseWindow\n                    }, React.createElement(FloatingWindowTab, {\n                      layout: this,\n                      node: child,\n                      factory: this.props.factory\n                    })));\n                    tabComponents[child.getId()] = React.createElement(TabFloating, {\n                      key: child.getId(),\n                      layout: this,\n                      path: _path,\n                      node: child,\n                      selected: i === border.getSelected()\n                    });\n                  } else {\n                    tabComponents[child.getId()] = React.createElement(Tab, {\n                      key: child.getId(),\n                      layout: this,\n                      path: _path,\n                      node: child,\n                      selected: i === border.getSelected(),\n                      factory: this.props.factory\n                    });\n                  }\n                }\n\n                i++;\n              }\n            } catch (err) {\n              _iterator3.e(err);\n            } finally {\n              _iterator3.f();\n            }\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n    /** @internal */\n\n  }, {\n    key: \"renderChildren\",\n    value: function renderChildren(path, node, tabSetComponents, tabComponents, floatingWindows, splitterComponents) {\n      var drawChildren = node._getDrawChildren();\n\n      var splitterCount = 0;\n      var tabCount = 0;\n      var rowCount = 0;\n\n      var _iterator4 = _createForOfIteratorHelper(drawChildren),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var child = _step4.value;\n\n          if (child instanceof SplitterNode) {\n            var newPath = path + \"/s\" + splitterCount++;\n            splitterComponents.push(React.createElement(Splitter, {\n              key: child.getId(),\n              layout: this,\n              path: newPath,\n              node: child\n            }));\n          } else if (child instanceof TabSetNode) {\n            var _newPath = path + \"/ts\" + rowCount++;\n\n            tabSetComponents.push(React.createElement(TabSet, {\n              key: child.getId(),\n              layout: this,\n              path: _newPath,\n              node: child,\n              iconFactory: this.props.iconFactory,\n              titleFactory: this.props.titleFactory,\n              icons: this.icons\n            }));\n            this.renderChildren(_newPath, child, tabSetComponents, tabComponents, floatingWindows, splitterComponents);\n          } else if (child instanceof TabNode) {\n            var _newPath2 = path + \"/t\" + tabCount++;\n\n            var selectedTab = child.getParent().getChildren()[child.getParent().getSelected()];\n\n            if (selectedTab === undefined) {\n              // this should not happen!\n              console.warn(\"undefined selectedTab should not happen\");\n            }\n\n            if (this.supportsPopout && child.isFloating()) {\n              var rect = this._getScreenRect(child);\n\n              floatingWindows.push(React.createElement(FloatingWindow, {\n                key: child.getId(),\n                url: this.popoutURL,\n                rect: rect,\n                title: child.getName(),\n                id: child.getId(),\n                onSetWindow: this.onSetWindow,\n                onCloseWindow: this.onCloseWindow\n              }, React.createElement(FloatingWindowTab, {\n                layout: this,\n                node: child,\n                factory: this.props.factory\n              })));\n              tabComponents[child.getId()] = React.createElement(TabFloating, {\n                key: child.getId(),\n                layout: this,\n                path: _newPath2,\n                node: child,\n                selected: child === selectedTab\n              });\n            } else {\n              tabComponents[child.getId()] = React.createElement(Tab, {\n                key: child.getId(),\n                layout: this,\n                path: _newPath2,\n                node: child,\n                selected: child === selectedTab,\n                factory: this.props.factory\n              });\n            }\n          } else {\n            // is row\n            var _newPath3 = path + (child.getOrientation() === Orientation.HORZ ? \"/r\" : \"/c\") + rowCount++;\n\n            this.renderChildren(_newPath3, child, tabSetComponents, tabComponents, floatingWindows, splitterComponents);\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n    }\n    /** @internal */\n\n  }, {\n    key: \"_getScreenRect\",\n    value: function _getScreenRect(node) {\n      var rect = node.getRect().clone();\n      var bodyRect = this.selfRef.current.getBoundingClientRect();\n      var navHeight = Math.min(80, this.currentWindow.outerHeight - this.currentWindow.innerHeight);\n      var navWidth = Math.min(80, this.currentWindow.outerWidth - this.currentWindow.innerWidth);\n      rect.x = rect.x + bodyRect.x + this.currentWindow.screenX + navWidth;\n      rect.y = rect.y + bodyRect.y + this.currentWindow.screenY + navHeight;\n      return rect;\n    }\n    /**\n     * Adds a new tab to the given tabset\n     * @param tabsetId the id of the tabset where the new tab will be added\n     * @param json the json for the new tab node\n     */\n\n  }, {\n    key: \"addTabToTabSet\",\n    value: function addTabToTabSet(tabsetId, json) {\n      var tabsetNode = this.props.model.getNodeById(tabsetId);\n\n      if (tabsetNode !== undefined) {\n        this.doAction(Actions.addNode(json, tabsetId, DockLocation.CENTER, -1));\n      }\n    }\n    /**\n     * Adds a new tab to the active tabset (if there is one)\n     * @param json the json for the new tab node\n     */\n\n  }, {\n    key: \"addTabToActiveTabSet\",\n    value: function addTabToActiveTabSet(json) {\n      var tabsetNode = this.props.model.getActiveTabset();\n\n      if (tabsetNode !== undefined) {\n        this.doAction(Actions.addNode(json, tabsetNode.getId(), DockLocation.CENTER, -1));\n      }\n    }\n    /**\n     * Adds a new tab by dragging a labeled panel to the drop location, dragging starts immediatelly\n     * @param dragText the text to show on the drag panel\n     * @param json the json for the new tab node\n     * @param onDrop a callback to call when the drag is complete (node and event will be undefined if the drag was cancelled)\n     */\n\n  }, {\n    key: \"addTabWithDragAndDrop\",\n    value: function addTabWithDragAndDrop(dragText, json, onDrop) {\n      this.fnNewNodeDropped = onDrop;\n      this.newTabJson = json;\n      this.dragStart(undefined, dragText, TabNode._fromJson(json, this.props.model, false), true, undefined, undefined);\n    }\n    /**\n     * Move a tab/tabset using drag and drop\n     * @param node the tab or tabset to drag\n     * @param dragText the text to show on the drag panel\n     */\n\n  }, {\n    key: \"moveTabWithDragAndDrop\",\n    value: function moveTabWithDragAndDrop(node, dragText) {\n      this.dragStart(undefined, dragText, node, true, undefined, undefined);\n    }\n    /**\n     * Adds a new tab by dragging a labeled panel to the drop location, dragging starts when you\n     * mouse down on the panel\n     *\n     * @param dragText the text to show on the drag panel\n     * @param json the json for the new tab node\n     * @param onDrop a callback to call when the drag is complete (node and event will be undefined if the drag was cancelled)\n     */\n\n  }, {\n    key: \"addTabWithDragAndDropIndirect\",\n    value: function addTabWithDragAndDropIndirect(dragText, json, onDrop) {\n      var _this3 = this;\n\n      this.fnNewNodeDropped = onDrop;\n      this.newTabJson = json;\n      DragDrop.instance.addGlass(this.onCancelAdd);\n      this.dragDivText = dragText;\n      this.dragDiv = this.currentDocument.createElement(\"div\");\n      this.dragDiv.className = this.getClassName(CLASSES.FLEXLAYOUT__DRAG_RECT);\n      this.dragDiv.addEventListener(\"mousedown\", this.onDragDivMouseDown);\n      this.dragDiv.addEventListener(\"touchstart\", this.onDragDivMouseDown, {\n        passive: false\n      });\n      this.dragRectRender(this.dragDivText, undefined, this.newTabJson, function () {\n        if (_this3.dragDiv) {\n          // now it's been rendered into the dom it can be centered\n          _this3.dragDiv.style.visibility = \"visible\";\n\n          var domRect = _this3.dragDiv.getBoundingClientRect();\n\n          var r = new Rect(0, 0, domRect === null || domRect === void 0 ? void 0 : domRect.width, domRect === null || domRect === void 0 ? void 0 : domRect.height);\n          r.centerInRect(_this3.state.rect);\n\n          _this3.dragDiv.setAttribute(\"data-layout-path\", \"/drag-rectangle\");\n\n          _this3.dragDiv.style.left = r.x + \"px\";\n          _this3.dragDiv.style.top = r.y + \"px\";\n        }\n      });\n      var rootdiv = this.selfRef.current;\n      rootdiv.appendChild(this.dragDiv);\n    }\n    /** @internal */\n\n  }, {\n    key: \"handleCustomTabDrag\",\n    value: function handleCustomTabDrag(dropInfo, pos, event) {\n      var _this4 = this;\n\n      var _a, _b, _c;\n\n      var invalidated = (_a = this.customDrop) === null || _a === void 0 ? void 0 : _a.invalidated;\n      var currentCallback = (_b = this.customDrop) === null || _b === void 0 ? void 0 : _b.callback;\n      this.customDrop = undefined;\n      var dragging = this.newTabJson || (this.dragNode instanceof TabNode ? this.dragNode : undefined);\n\n      if (dragging && (dropInfo.node instanceof TabSetNode || dropInfo.node instanceof BorderNode) && dropInfo.index === -1) {\n        var selected = dropInfo.node.getSelectedNode();\n        var tabRect = selected === null || selected === void 0 ? void 0 : selected.getRect();\n\n        if (selected && (tabRect === null || tabRect === void 0 ? void 0 : tabRect.contains(pos.x, pos.y))) {\n          var customDrop = undefined;\n\n          try {\n            var dest = this.onTabDrag(dragging, selected, pos.x - tabRect.x, pos.y - tabRect.y, dropInfo.location, function () {\n              return _this4.onDragMove(event);\n            });\n\n            if (dest) {\n              customDrop = {\n                rect: new Rect(dest.x + tabRect.x, dest.y + tabRect.y, dest.width, dest.height),\n                callback: dest.callback,\n                invalidated: dest.invalidated,\n                dragging: dragging,\n                over: selected,\n                x: pos.x - tabRect.x,\n                y: pos.y - tabRect.y,\n                location: dropInfo.location,\n                cursor: dest.cursor\n              };\n            }\n          } catch (e) {\n            console.error(e);\n          }\n\n          if ((customDrop === null || customDrop === void 0 ? void 0 : customDrop.callback) === currentCallback) {\n            invalidated = undefined;\n          }\n\n          this.customDrop = customDrop;\n        }\n      }\n\n      this.dropInfo = dropInfo;\n      this.outlineDiv.className = this.getClassName(this.customDrop ? CLASSES.FLEXLAYOUT__OUTLINE_RECT : dropInfo.className);\n\n      if (this.customDrop) {\n        this.customDrop.rect.positionElement(this.outlineDiv);\n      } else {\n        dropInfo.rect.positionElement(this.outlineDiv);\n      }\n\n      DragDrop.instance.setGlassCursorOverride((_c = this.customDrop) === null || _c === void 0 ? void 0 : _c.cursor);\n      this.outlineDiv.style.visibility = \"visible\";\n\n      try {\n        invalidated === null || invalidated === void 0 ? void 0 : invalidated();\n      } catch (e) {\n        console.error(e);\n      }\n    }\n    /** @internal */\n\n  }, {\n    key: \"onDragEnter\",\n    value: function onDragEnter(event) {\n      // DragDrop keeps track of number of dragenters minus the number of\n      // dragleaves. Only start a new drag if there isn't one already.\n      if (DragDrop.instance.isDragging()) return;\n      var drag = this.props.onExternalDrag(event);\n\n      if (drag) {\n        // Mimic addTabWithDragAndDrop, but pass in DragEvent\n        this.fnNewNodeDropped = drag.onDrop;\n        this.newTabJson = drag.json;\n        this.dragStart(event, drag.dragText, TabNode._fromJson(drag.json, this.props.model, false), true, undefined, undefined);\n      }\n    }\n    /** @internal */\n\n  }, {\n    key: \"checkForBorderToShow\",\n    value: function checkForBorderToShow(x, y) {\n      var r = this.props.model._getOuterInnerRects().outer;\n\n      var c = r.getCenter();\n      var margin = this.edgeRectWidth;\n      var offset = this.edgeRectLength / 2;\n      var overEdge = false;\n\n      if (this.props.model.isEnableEdgeDock() && this.state.showHiddenBorder === DockLocation.CENTER) {\n        if (y > c.y - offset && y < c.y + offset || x > c.x - offset && x < c.x + offset) {\n          overEdge = true;\n        }\n      }\n\n      var location = DockLocation.CENTER;\n\n      if (!overEdge) {\n        if (x <= r.x + margin) {\n          location = DockLocation.LEFT;\n        } else if (x >= r.getRight() - margin) {\n          location = DockLocation.RIGHT;\n        } else if (y <= r.y + margin) {\n          location = DockLocation.TOP;\n        } else if (y >= r.getBottom() - margin) {\n          location = DockLocation.BOTTOM;\n        }\n      }\n\n      if (location !== this.state.showHiddenBorder) {\n        this.setState({\n          showHiddenBorder: location\n        });\n      }\n    }\n    /** @internal */\n\n  }, {\n    key: \"maximize\",\n    value: function maximize(tabsetNode) {\n      this.doAction(Actions.maximizeToggle(tabsetNode.getId()));\n    }\n    /** @internal */\n\n  }, {\n    key: \"customizeTab\",\n    value: function customizeTab(tabNode, renderValues) {\n      if (this.props.onRenderTab) {\n        this.props.onRenderTab(tabNode, renderValues);\n      }\n    }\n    /** @internal */\n\n  }, {\n    key: \"customizeTabSet\",\n    value: function customizeTabSet(tabSetNode, renderValues) {\n      if (this.props.onRenderTabSet) {\n        this.props.onRenderTabSet(tabSetNode, renderValues);\n      }\n    }\n    /** @internal */\n\n  }, {\n    key: \"i18nName\",\n    value: function i18nName(id, param) {\n      var message;\n\n      if (this.props.i18nMapper) {\n        message = this.props.i18nMapper(id, param);\n      }\n\n      if (message === undefined) {\n        message = id + (param === undefined ? \"\" : param);\n      }\n\n      return message;\n    }\n    /** @internal */\n\n  }, {\n    key: \"getOnRenderFloatingTabPlaceholder\",\n    value: function getOnRenderFloatingTabPlaceholder() {\n      return this.props.onRenderFloatingTabPlaceholder;\n    }\n    /** @internal */\n\n  }, {\n    key: \"getShowOverflowMenu\",\n    value: function getShowOverflowMenu() {\n      return this.props.onShowOverflowMenu;\n    }\n    /** @internal */\n\n  }, {\n    key: \"getTabSetPlaceHolderCallback\",\n    value: function getTabSetPlaceHolderCallback() {\n      return this.props.onTabSetPlaceHolder;\n    }\n    /** @internal */\n\n  }, {\n    key: \"showContextMenu\",\n    value: function showContextMenu(node, event) {\n      if (this.props.onContextMenu) {\n        this.props.onContextMenu(node, event);\n      }\n    }\n    /** @internal */\n\n  }, {\n    key: \"auxMouseClick\",\n    value: function auxMouseClick(node, event) {\n      if (this.props.onAuxMouseClick) {\n        this.props.onAuxMouseClick(node, event);\n      }\n    }\n  }]);\n\n  return Layout;\n}(React.Component);\n/** @internal */\n\nvar DragRectRenderWrapper = function DragRectRenderWrapper(props) {\n  React.useEffect(function () {\n    var _a;\n\n    (_a = props.onRendered) === null || _a === void 0 ? void 0 : _a.call(props);\n  }, [props]);\n  return React.createElement(React.Fragment, null, props.children);\n};","map":null,"metadata":{},"sourceType":"module"}