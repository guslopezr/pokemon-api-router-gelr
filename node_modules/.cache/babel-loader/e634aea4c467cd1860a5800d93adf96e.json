{"ast":null,"code":"import _classCallCheck from \"/Users/gustavolopez/Documents/Personal GLR/Curso Desafio Latam/MOD REACT 7 ROUTER 2/poke-api router gelr/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/gustavolopez/Documents/Personal GLR/Curso Desafio Latam/MOD REACT 7 ROUTER 2/poke-api router gelr/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/gustavolopez/Documents/Personal GLR/Curso Desafio Latam/MOD REACT 7 ROUTER 2/poke-api router gelr/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/gustavolopez/Documents/Personal GLR/Curso Desafio Latam/MOD REACT 7 ROUTER 2/poke-api router gelr/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/gustavolopez/Documents/Personal GLR/Curso Desafio Latam/MOD REACT 7 ROUTER 2/poke-api router gelr/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _assertThisInitialized from \"/Users/gustavolopez/Documents/Personal GLR/Curso Desafio Latam/MOD REACT 7 ROUTER 2/poke-api router gelr/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport { Attribute } from \"../Attribute\";\nimport { AttributeDefinitions } from \"../AttributeDefinitions\";\nimport { DockLocation } from \"../DockLocation\";\nimport { DropInfo } from \"../DropInfo\";\nimport { Orientation } from \"../Orientation\";\nimport { Rect } from \"../Rect\";\nimport { CLASSES } from \"../Types\";\nimport { Node } from \"./Node\";\nimport { SplitterNode } from \"./SplitterNode\";\nimport { TabNode } from \"./TabNode\";\nimport { adjustSelectedIndex } from \"./Utils\";\nexport var BorderNode = /*#__PURE__*/function (_Node) {\n  _inherits(BorderNode, _Node);\n\n  /** @internal */\n  function BorderNode(location, json, model) {\n    var _this;\n\n    _classCallCheck(this, BorderNode);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(BorderNode).call(this, model));\n    /** @internal */\n\n    _this._adjustedSize = 0;\n    /** @internal */\n\n    _this._calculatedBorderBarSize = 0;\n    _this._location = location;\n    _this._drawChildren = [];\n    _this._attributes.id = \"border_\".concat(location.getName());\n\n    BorderNode._attributeDefinitions.fromJson(json, _this._attributes);\n\n    model._addNode(_assertThisInitialized(_assertThisInitialized(_this)));\n\n    return _this;\n  }\n  /** @internal */\n\n\n  _createClass(BorderNode, [{\n    key: \"getLocation\",\n    value: function getLocation() {\n      return this._location;\n    }\n  }, {\n    key: \"getTabHeaderRect\",\n    value: function getTabHeaderRect() {\n      return this._tabHeaderRect;\n    }\n  }, {\n    key: \"getRect\",\n    value: function getRect() {\n      return this._tabHeaderRect;\n    }\n  }, {\n    key: \"getContentRect\",\n    value: function getContentRect() {\n      return this._contentRect;\n    }\n  }, {\n    key: \"isEnableDrop\",\n    value: function isEnableDrop() {\n      return this._getAttr(\"enableDrop\");\n    }\n  }, {\n    key: \"isAutoSelectTab\",\n    value: function isAutoSelectTab(whenOpen) {\n      if (whenOpen == null) {\n        whenOpen = this.getSelected() !== -1;\n      }\n\n      if (whenOpen) {\n        return this._getAttr(\"autoSelectTabWhenOpen\");\n      } else {\n        return this._getAttr(\"autoSelectTabWhenClosed\");\n      }\n    }\n  }, {\n    key: \"getClassName\",\n    value: function getClassName() {\n      return this._getAttr(\"className\");\n    }\n    /** @internal */\n\n  }, {\n    key: \"calcBorderBarSize\",\n    value: function calcBorderBarSize(metrics) {\n      var barSize = this._getAttr(\"barSize\");\n\n      if (barSize !== 0) {\n        // its defined\n        this._calculatedBorderBarSize = barSize;\n      } else {\n        this._calculatedBorderBarSize = metrics.borderBarSize;\n      }\n    }\n  }, {\n    key: \"getBorderBarSize\",\n    value: function getBorderBarSize() {\n      return this._calculatedBorderBarSize;\n    }\n  }, {\n    key: \"getSize\",\n    value: function getSize() {\n      var defaultSize = this._getAttr(\"size\");\n\n      var selected = this.getSelected();\n\n      if (selected === -1) {\n        return defaultSize;\n      } else {\n        var tabNode = this._children[selected];\n        var tabBorderSize = this._location._orientation === Orientation.HORZ ? tabNode._getAttr(\"borderWidth\") : tabNode._getAttr(\"borderHeight\");\n\n        if (tabBorderSize === -1) {\n          return defaultSize;\n        } else {\n          return tabBorderSize;\n        }\n      }\n    }\n  }, {\n    key: \"getMinSize\",\n    value: function getMinSize() {\n      return this._getAttr(\"minSize\");\n    }\n  }, {\n    key: \"getSelected\",\n    value: function getSelected() {\n      return this._attributes.selected;\n    }\n  }, {\n    key: \"getSelectedNode\",\n    value: function getSelectedNode() {\n      if (this.getSelected() !== -1) {\n        return this._children[this.getSelected()];\n      }\n\n      return undefined;\n    }\n  }, {\n    key: \"getOrientation\",\n    value: function getOrientation() {\n      return this._location.getOrientation();\n    }\n    /**\n     * Returns the config attribute that can be used to store node specific data that\n     * WILL be saved to the json. The config attribute should be changed via the action Actions.updateNodeAttributes rather\n     * than directly, for example:\n     * this.state.model.doAction(\n     *   FlexLayout.Actions.updateNodeAttributes(node.getId(), {config:myConfigObject}));\n     */\n\n  }, {\n    key: \"getConfig\",\n    value: function getConfig() {\n      return this._attributes.config;\n    }\n  }, {\n    key: \"isMaximized\",\n    value: function isMaximized() {\n      return false;\n    }\n  }, {\n    key: \"isShowing\",\n    value: function isShowing() {\n      var show = this._attributes.show;\n\n      if (show) {\n        if (this._model._getShowHiddenBorder() !== this._location && this.isAutoHide() && this._children.length === 0) {\n          return false;\n        }\n\n        return true;\n      } else {\n        return false;\n      }\n    }\n  }, {\n    key: \"isAutoHide\",\n    value: function isAutoHide() {\n      return this._getAttr(\"enableAutoHide\");\n    }\n    /** @internal */\n\n  }, {\n    key: \"_setSelected\",\n    value: function _setSelected(index) {\n      this._attributes.selected = index;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_setSize\",\n    value: function _setSize(pos) {\n      var selected = this.getSelected();\n\n      if (selected === -1) {\n        this._attributes.size = pos;\n      } else {\n        var tabNode = this._children[selected];\n        var tabBorderSize = this._location._orientation === Orientation.HORZ ? tabNode._getAttr(\"borderWidth\") : tabNode._getAttr(\"borderHeight\");\n\n        if (tabBorderSize === -1) {\n          this._attributes.size = pos;\n        } else {\n          if (this._location._orientation === Orientation.HORZ) {\n            tabNode._setBorderWidth(pos);\n          } else {\n            tabNode._setBorderHeight(pos);\n          }\n        }\n      }\n    }\n    /** @internal */\n\n  }, {\n    key: \"_updateAttrs\",\n    value: function _updateAttrs(json) {\n      BorderNode._attributeDefinitions.update(json, this._attributes);\n    }\n    /** @internal */\n\n  }, {\n    key: \"_getDrawChildren\",\n    value: function _getDrawChildren() {\n      return this._drawChildren;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_setAdjustedSize\",\n    value: function _setAdjustedSize(size) {\n      this._adjustedSize = size;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_getAdjustedSize\",\n    value: function _getAdjustedSize() {\n      return this._adjustedSize;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_layoutBorderOuter\",\n    value: function _layoutBorderOuter(outer, metrics) {\n      this.calcBorderBarSize(metrics);\n\n      var split1 = this._location.split(outer, this.getBorderBarSize()); // split border outer\n\n\n      this._tabHeaderRect = split1.start;\n      return split1.end;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_layoutBorderInner\",\n    value: function _layoutBorderInner(inner, metrics) {\n      this._drawChildren = [];\n      var location = this._location;\n      var split1 = location.split(inner, this._adjustedSize + this._model.getSplitterSize()); // split off tab contents\n\n      var split2 = location.reflect().split(split1.start, this._model.getSplitterSize()); // split contents into content and splitter\n\n      this._contentRect = split2.end;\n\n      for (var i = 0; i < this._children.length; i++) {\n        var child = this._children[i];\n\n        child._layout(this._contentRect, metrics);\n\n        child._setVisible(i === this.getSelected());\n\n        this._drawChildren.push(child);\n      }\n\n      if (this.getSelected() === -1) {\n        return inner;\n      } else {\n        var newSplitter = new SplitterNode(this._model);\n\n        newSplitter._setParent(this);\n\n        newSplitter._setRect(split2.start);\n\n        this._drawChildren.push(newSplitter);\n\n        return split1.end;\n      }\n    }\n    /** @internal */\n\n  }, {\n    key: \"_remove\",\n    value: function _remove(node) {\n      var removedIndex = this._removeChild(node);\n\n      if (this.getSelected() !== -1) {\n        adjustSelectedIndex(this, removedIndex);\n      }\n    }\n    /** @internal */\n\n  }, {\n    key: \"canDrop\",\n    value: function canDrop(dragNode, x, y) {\n      if (dragNode.getType() !== TabNode.TYPE) {\n        return undefined;\n      }\n\n      var dropInfo;\n      var dockLocation = DockLocation.CENTER;\n\n      if (this._tabHeaderRect.contains(x, y)) {\n        if (this._location._orientation === Orientation.VERT) {\n          if (this._children.length > 0) {\n            var child = this._children[0];\n            var childRect = child.getTabRect();\n            var childY = childRect.y;\n            var childHeight = childRect.height;\n            var pos = this._tabHeaderRect.x;\n            var childCenter = 0;\n\n            for (var i = 0; i < this._children.length; i++) {\n              child = this._children[i];\n              childRect = child.getTabRect();\n              childCenter = childRect.x + childRect.width / 2;\n\n              if (x >= pos && x < childCenter) {\n                var outlineRect = new Rect(childRect.x - 2, childY, 3, childHeight);\n                dropInfo = new DropInfo(this, outlineRect, dockLocation, i, CLASSES.FLEXLAYOUT__OUTLINE_RECT);\n                break;\n              }\n\n              pos = childCenter;\n            }\n\n            if (dropInfo == null) {\n              var _outlineRect = new Rect(childRect.getRight() - 2, childY, 3, childHeight);\n\n              dropInfo = new DropInfo(this, _outlineRect, dockLocation, this._children.length, CLASSES.FLEXLAYOUT__OUTLINE_RECT);\n            }\n          } else {\n            var _outlineRect2 = new Rect(this._tabHeaderRect.x + 1, this._tabHeaderRect.y + 2, 3, 18);\n\n            dropInfo = new DropInfo(this, _outlineRect2, dockLocation, 0, CLASSES.FLEXLAYOUT__OUTLINE_RECT);\n          }\n        } else {\n          if (this._children.length > 0) {\n            var _child = this._children[0];\n\n            var _childRect = _child.getTabRect();\n\n            var childX = _childRect.x;\n            var childWidth = _childRect.width;\n            var _pos = this._tabHeaderRect.y;\n            var _childCenter = 0;\n\n            for (var _i = 0; _i < this._children.length; _i++) {\n              _child = this._children[_i];\n              _childRect = _child.getTabRect();\n              _childCenter = _childRect.y + _childRect.height / 2;\n\n              if (y >= _pos && y < _childCenter) {\n                var _outlineRect3 = new Rect(childX, _childRect.y - 2, childWidth, 3);\n\n                dropInfo = new DropInfo(this, _outlineRect3, dockLocation, _i, CLASSES.FLEXLAYOUT__OUTLINE_RECT);\n                break;\n              }\n\n              _pos = _childCenter;\n            }\n\n            if (dropInfo == null) {\n              var _outlineRect4 = new Rect(childX, _childRect.getBottom() - 2, childWidth, 3);\n\n              dropInfo = new DropInfo(this, _outlineRect4, dockLocation, this._children.length, CLASSES.FLEXLAYOUT__OUTLINE_RECT);\n            }\n          } else {\n            var _outlineRect5 = new Rect(this._tabHeaderRect.x + 2, this._tabHeaderRect.y + 1, 18, 3);\n\n            dropInfo = new DropInfo(this, _outlineRect5, dockLocation, 0, CLASSES.FLEXLAYOUT__OUTLINE_RECT);\n          }\n        }\n\n        if (!dragNode._canDockInto(dragNode, dropInfo)) {\n          return undefined;\n        }\n      } else if (this.getSelected() !== -1 && this._contentRect.contains(x, y)) {\n        var _outlineRect6 = this._contentRect;\n        dropInfo = new DropInfo(this, _outlineRect6, dockLocation, -1, CLASSES.FLEXLAYOUT__OUTLINE_RECT);\n\n        if (!dragNode._canDockInto(dragNode, dropInfo)) {\n          return undefined;\n        }\n      }\n\n      return dropInfo;\n    }\n    /** @internal */\n\n  }, {\n    key: \"drop\",\n    value: function drop(dragNode, location, index, select) {\n      var fromIndex = 0;\n      var dragParent = dragNode.getParent();\n\n      if (dragParent !== undefined) {\n        fromIndex = dragParent._removeChild(dragNode); // if selected node in border is being docked into a different border then deselect border tabs\n\n        if (dragParent !== this && dragParent instanceof BorderNode && dragParent.getSelected() === fromIndex) {\n          dragParent._setSelected(-1);\n        } else {\n          adjustSelectedIndex(dragParent, fromIndex);\n        }\n      } // if dropping a tab back to same tabset and moving to forward position then reduce insertion index\n\n\n      if (dragNode.getType() === TabNode.TYPE && dragParent === this && fromIndex < index && index > 0) {\n        index--;\n      } // simple_bundled dock to existing tabset\n\n\n      var insertPos = index;\n\n      if (insertPos === -1) {\n        insertPos = this._children.length;\n      }\n\n      if (dragNode.getType() === TabNode.TYPE) {\n        this._addChild(dragNode, insertPos);\n      }\n\n      if (select || select !== false && this.isAutoSelectTab()) {\n        this._setSelected(insertPos);\n      }\n\n      this._model._tidy();\n    }\n  }, {\n    key: \"toJson\",\n    value: function toJson() {\n      var json = {};\n\n      BorderNode._attributeDefinitions.toJson(json, this._attributes);\n\n      json.location = this._location.getName();\n      json.children = this._children.map(function (child) {\n        return child.toJson();\n      });\n      return json;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_getSplitterBounds\",\n    value: function _getSplitterBounds(splitter) {\n      var useMinSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var pBounds = [0, 0];\n      var minSize = useMinSize ? this.getMinSize() : 0;\n\n      var outerRect = this._model._getOuterInnerRects().outer;\n\n      var innerRect = this._model._getOuterInnerRects().inner;\n\n      var rootRow = this._model.getRoot();\n\n      if (this._location === DockLocation.TOP) {\n        pBounds[0] = outerRect.y + minSize;\n        pBounds[1] = Math.max(pBounds[0], innerRect.getBottom() - splitter.getHeight() - rootRow.getMinHeight());\n      } else if (this._location === DockLocation.LEFT) {\n        pBounds[0] = outerRect.x + minSize;\n        pBounds[1] = Math.max(pBounds[0], innerRect.getRight() - splitter.getWidth() - rootRow.getMinWidth());\n      } else if (this._location === DockLocation.BOTTOM) {\n        pBounds[1] = outerRect.getBottom() - splitter.getHeight() - minSize;\n        pBounds[0] = Math.min(pBounds[1], innerRect.y + rootRow.getMinHeight());\n      } else if (this._location === DockLocation.RIGHT) {\n        pBounds[1] = outerRect.getRight() - splitter.getWidth() - minSize;\n        pBounds[0] = Math.min(pBounds[1], innerRect.x + rootRow.getMinWidth());\n      }\n\n      return pBounds;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_calculateSplit\",\n    value: function _calculateSplit(splitter, splitterPos) {\n      var pBounds = this._getSplitterBounds(splitter);\n\n      if (this._location === DockLocation.BOTTOM || this._location === DockLocation.RIGHT) {\n        return Math.max(0, pBounds[1] - splitterPos);\n      } else {\n        return Math.max(0, splitterPos - pBounds[0]);\n      }\n    }\n    /** @internal */\n\n  }, {\n    key: \"_getAttributeDefinitions\",\n    value: function _getAttributeDefinitions() {\n      return BorderNode._attributeDefinitions;\n    }\n    /** @internal */\n\n  }], [{\n    key: \"_fromJson\",\n    value: function _fromJson(json, model) {\n      var location = DockLocation.getByName(json.location);\n      var border = new BorderNode(location, json, model);\n\n      if (json.children) {\n        border._children = json.children.map(function (jsonChild) {\n          var child = TabNode._fromJson(jsonChild, model);\n\n          child._setParent(border);\n\n          return child;\n        });\n      }\n\n      return border;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_createAttributeDefinitions\",\n    value: function _createAttributeDefinitions() {\n      var attributeDefinitions = new AttributeDefinitions();\n      attributeDefinitions.add(\"type\", BorderNode.TYPE, true).setType(Attribute.STRING).setFixed();\n      attributeDefinitions.add(\"selected\", -1).setType(Attribute.NUMBER);\n      attributeDefinitions.add(\"show\", true).setType(Attribute.BOOLEAN);\n      attributeDefinitions.add(\"config\", undefined).setType(\"any\");\n      attributeDefinitions.addInherited(\"barSize\", \"borderBarSize\").setType(Attribute.NUMBER);\n      attributeDefinitions.addInherited(\"enableDrop\", \"borderEnableDrop\").setType(Attribute.BOOLEAN);\n      attributeDefinitions.addInherited(\"className\", \"borderClassName\").setType(Attribute.STRING);\n      attributeDefinitions.addInherited(\"autoSelectTabWhenOpen\", \"borderAutoSelectTabWhenOpen\").setType(Attribute.BOOLEAN);\n      attributeDefinitions.addInherited(\"autoSelectTabWhenClosed\", \"borderAutoSelectTabWhenClosed\").setType(Attribute.BOOLEAN);\n      attributeDefinitions.addInherited(\"size\", \"borderSize\").setType(Attribute.NUMBER);\n      attributeDefinitions.addInherited(\"minSize\", \"borderMinSize\").setType(Attribute.NUMBER);\n      attributeDefinitions.addInherited(\"enableAutoHide\", \"borderEnableAutoHide\").setType(Attribute.BOOLEAN);\n      return attributeDefinitions;\n    }\n  }, {\n    key: \"getAttributeDefinitions\",\n    value: function getAttributeDefinitions() {\n      return BorderNode._attributeDefinitions;\n    }\n  }]);\n\n  return BorderNode;\n}(Node);\nBorderNode.TYPE = \"border\";\n/** @internal */\n\nBorderNode._attributeDefinitions = BorderNode._createAttributeDefinitions();","map":null,"metadata":{},"sourceType":"module"}