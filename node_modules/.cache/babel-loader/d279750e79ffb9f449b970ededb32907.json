{"ast":null,"code":"import _toConsumableArray from \"/Users/gustavolopez/Documents/Personal GLR/Curso Desafio Latam/MOD REACT 7 ROUTER 2/poke-api router gelr/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/Users/gustavolopez/Documents/Personal GLR/Curso Desafio Latam/MOD REACT 7 ROUTER 2/poke-api router gelr/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/gustavolopez/Documents/Personal GLR/Curso Desafio Latam/MOD REACT 7 ROUTER 2/poke-api router gelr/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { v4 as getUUID } from \"uuid\";\nimport { Attribute } from \"../Attribute\";\nimport { AttributeDefinitions } from \"../AttributeDefinitions\";\nimport { DockLocation } from \"../DockLocation\";\nimport { Orientation } from \"../Orientation\";\nimport { Rect } from \"../Rect\";\nimport { Actions } from \"./Actions\";\nimport { BorderNode } from \"./BorderNode\";\nimport { BorderSet } from \"./BorderSet\";\nimport { RowNode } from \"./RowNode\";\nimport { TabNode } from \"./TabNode\";\nimport { TabSetNode } from \"./TabSetNode\";\nimport { adjustSelectedIndexAfterDock, adjustSelectedIndexAfterFloat } from \"./Utils\";\n/**\n * Class containing the Tree of Nodes used by the FlexLayout component\n */\n\nexport var Model = /*#__PURE__*/function () {\n  /**\n   * 'private' constructor. Use the static method Model.fromJson(json) to create a model\n   *  @internal\n   */\n  function Model() {\n    _classCallCheck(this, Model);\n\n    /** @internal */\n    this._borderRects = {\n      inner: Rect.empty(),\n      outer: Rect.empty()\n    };\n    this._attributes = {};\n    this._idMap = {};\n    this._borders = new BorderSet(this);\n    this._pointerFine = true;\n    this._showHiddenBorder = DockLocation.CENTER;\n  }\n  /**\n   * Loads the model from the given json object\n   * @param json the json model to load\n   * @returns {Model} a new Model object\n   */\n\n\n  _createClass(Model, [{\n    key: \"_setChangeListener\",\n\n    /** @internal */\n    value: function _setChangeListener(listener) {\n      this._changeListener = listener;\n    }\n    /**\n     * Get the currently active tabset node\n     */\n\n  }, {\n    key: \"getActiveTabset\",\n    value: function getActiveTabset() {\n      if (this._activeTabSet && this.getNodeById(this._activeTabSet.getId())) {\n        return this._activeTabSet;\n      } else {\n        return undefined;\n      }\n    }\n    /** @internal */\n\n  }, {\n    key: \"_getShowHiddenBorder\",\n    value: function _getShowHiddenBorder() {\n      return this._showHiddenBorder;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_setShowHiddenBorder\",\n    value: function _setShowHiddenBorder(location) {\n      this._showHiddenBorder = location;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_setActiveTabset\",\n    value: function _setActiveTabset(tabsetNode) {\n      this._activeTabSet = tabsetNode;\n    }\n    /**\n     * Get the currently maximized tabset node\n     */\n\n  }, {\n    key: \"getMaximizedTabset\",\n    value: function getMaximizedTabset() {\n      return this._maximizedTabSet;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_setMaximizedTabset\",\n    value: function _setMaximizedTabset(tabsetNode) {\n      this._maximizedTabSet = tabsetNode;\n    }\n    /**\n     * Gets the root RowNode of the model\n     * @returns {RowNode}\n     */\n\n  }, {\n    key: \"getRoot\",\n    value: function getRoot() {\n      return this._root;\n    }\n  }, {\n    key: \"isRootOrientationVertical\",\n    value: function isRootOrientationVertical() {\n      return this._attributes.rootOrientationVertical;\n    }\n  }, {\n    key: \"isUseVisibility\",\n    value: function isUseVisibility() {\n      return this._attributes.enableUseVisibility;\n    }\n    /**\n     * Gets the\n     * @returns {BorderSet|*}\n     */\n\n  }, {\n    key: \"getBorderSet\",\n    value: function getBorderSet() {\n      return this._borders;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_getOuterInnerRects\",\n    value: function _getOuterInnerRects() {\n      return this._borderRects;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_getPointerFine\",\n    value: function _getPointerFine() {\n      return this._pointerFine;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_setPointerFine\",\n    value: function _setPointerFine(pointerFine) {\n      this._pointerFine = pointerFine;\n    }\n    /**\n     * Visits all the nodes in the model and calls the given function for each\n     * @param fn a function that takes visited node and a integer level as parameters\n     */\n\n  }, {\n    key: \"visitNodes\",\n    value: function visitNodes(fn) {\n      this._borders._forEachNode(fn);\n\n      this._root._forEachNode(fn, 0);\n    }\n    /**\n     * Gets a node by its id\n     * @param id the id to find\n     */\n\n  }, {\n    key: \"getNodeById\",\n    value: function getNodeById(id) {\n      return this._idMap[id];\n    }\n    /**\n     * Update the node tree by performing the given action,\n     * Actions should be generated via static methods on the Actions class\n     * @param action the action to perform\n     * @returns added Node for Actions.addNode; undefined otherwise\n     */\n\n  }, {\n    key: \"doAction\",\n    value: function doAction(action) {\n      var returnVal = undefined; // console.log(action);\n\n      switch (action.type) {\n        case Actions.ADD_NODE:\n          {\n            var newNode = new TabNode(this, action.data.json, true);\n            var toNode = this._idMap[action.data.toNode];\n\n            if (toNode instanceof TabSetNode || toNode instanceof BorderNode || toNode instanceof RowNode) {\n              toNode.drop(newNode, DockLocation.getByName(action.data.location), action.data.index, action.data.select);\n              returnVal = newNode;\n            }\n\n            break;\n          }\n\n        case Actions.MOVE_NODE:\n          {\n            var fromNode = this._idMap[action.data.fromNode];\n\n            if (fromNode instanceof TabNode || fromNode instanceof TabSetNode) {\n              var _toNode = this._idMap[action.data.toNode];\n\n              if (_toNode instanceof TabSetNode || _toNode instanceof BorderNode || _toNode instanceof RowNode) {\n                _toNode.drop(fromNode, DockLocation.getByName(action.data.location), action.data.index, action.data.select);\n              }\n            }\n\n            break;\n          }\n\n        case Actions.DELETE_TAB:\n          {\n            var node = this._idMap[action.data.node];\n\n            if (node instanceof TabNode) {\n              node._delete();\n            }\n\n            break;\n          }\n\n        case Actions.DELETE_TABSET:\n          {\n            var _node = this._idMap[action.data.node];\n\n            if (_node instanceof TabSetNode) {\n              // first delete all child tabs that are closeable\n              var children = _toConsumableArray(_node.getChildren());\n\n              for (var i = 0; i < children.length; i++) {\n                var child = children[i];\n\n                if (child.isEnableClose()) {\n                  child._delete();\n                }\n              }\n\n              if (_node.getChildren().length === 0) {\n                _node._delete();\n              }\n\n              this._tidy();\n            }\n\n            break;\n          }\n\n        case Actions.FLOAT_TAB:\n          {\n            var _node2 = this._idMap[action.data.node];\n\n            if (_node2 instanceof TabNode) {\n              _node2._setFloating(true);\n\n              adjustSelectedIndexAfterFloat(_node2);\n            }\n\n            break;\n          }\n\n        case Actions.UNFLOAT_TAB:\n          {\n            var _node3 = this._idMap[action.data.node];\n\n            if (_node3 instanceof TabNode) {\n              _node3._setFloating(false);\n\n              adjustSelectedIndexAfterDock(_node3);\n            }\n\n            break;\n          }\n\n        case Actions.RENAME_TAB:\n          {\n            var _node4 = this._idMap[action.data.node];\n\n            if (_node4 instanceof TabNode) {\n              _node4._setName(action.data.text);\n            }\n\n            break;\n          }\n\n        case Actions.SELECT_TAB:\n          {\n            var tabNode = this._idMap[action.data.tabNode];\n\n            if (tabNode instanceof TabNode) {\n              var parent = tabNode.getParent();\n              var pos = parent.getChildren().indexOf(tabNode);\n\n              if (parent instanceof BorderNode) {\n                if (parent.getSelected() === pos) {\n                  parent._setSelected(-1);\n                } else {\n                  parent._setSelected(pos);\n                }\n              } else if (parent instanceof TabSetNode) {\n                if (parent.getSelected() !== pos) {\n                  parent._setSelected(pos);\n                }\n\n                this._activeTabSet = parent;\n              }\n            }\n\n            break;\n          }\n\n        case Actions.SET_ACTIVE_TABSET:\n          {\n            var tabsetNode = this._idMap[action.data.tabsetNode];\n\n            if (tabsetNode instanceof TabSetNode) {\n              this._activeTabSet = tabsetNode;\n            }\n\n            break;\n          }\n\n        case Actions.ADJUST_SPLIT:\n          {\n            var node1 = this._idMap[action.data.node1];\n            var node2 = this._idMap[action.data.node2];\n\n            if ((node1 instanceof TabSetNode || node1 instanceof RowNode) && (node2 instanceof TabSetNode || node2 instanceof RowNode)) {\n              this._adjustSplitSide(node1, action.data.weight1, action.data.pixelWidth1);\n\n              this._adjustSplitSide(node2, action.data.weight2, action.data.pixelWidth2);\n            }\n\n            break;\n          }\n\n        case Actions.ADJUST_BORDER_SPLIT:\n          {\n            var _node5 = this._idMap[action.data.node];\n\n            if (_node5 instanceof BorderNode) {\n              _node5._setSize(action.data.pos);\n            }\n\n            break;\n          }\n\n        case Actions.MAXIMIZE_TOGGLE:\n          {\n            var _node6 = this._idMap[action.data.node];\n\n            if (_node6 instanceof TabSetNode) {\n              if (_node6 === this._maximizedTabSet) {\n                this._maximizedTabSet = undefined;\n              } else {\n                this._maximizedTabSet = _node6;\n                this._activeTabSet = _node6;\n              }\n            }\n\n            break;\n          }\n\n        case Actions.UPDATE_MODEL_ATTRIBUTES:\n          {\n            this._updateAttrs(action.data.json);\n\n            break;\n          }\n\n        case Actions.UPDATE_NODE_ATTRIBUTES:\n          {\n            var _node7 = this._idMap[action.data.node];\n\n            _node7._updateAttrs(action.data.json);\n\n            break;\n          }\n\n        default:\n          break;\n      }\n\n      this._updateIdMap();\n\n      if (this._changeListener !== undefined) {\n        this._changeListener();\n      }\n\n      return returnVal;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_updateIdMap\",\n    value: function _updateIdMap() {\n      var _this = this;\n\n      // regenerate idMap to stop it building up\n      this._idMap = {};\n      this.visitNodes(function (node) {\n        return _this._idMap[node.getId()] = node;\n      }); // console.log(JSON.stringify(Object.keys(this._idMap)));\n    }\n    /** @internal */\n\n  }, {\n    key: \"_adjustSplitSide\",\n    value: function _adjustSplitSide(node, weight, pixels) {\n      node._setWeight(weight);\n\n      if (node.getWidth() != null && node.getOrientation() === Orientation.VERT) {\n        node._updateAttrs({\n          width: pixels\n        });\n      } else if (node.getHeight() != null && node.getOrientation() === Orientation.HORZ) {\n        node._updateAttrs({\n          height: pixels\n        });\n      }\n    }\n    /**\n     * Converts the model to a json object\n     * @returns {IJsonModel} json object that represents this model\n     */\n\n  }, {\n    key: \"toJson\",\n    value: function toJson() {\n      var global = {};\n\n      Model._attributeDefinitions.toJson(global, this._attributes); // save state of nodes\n\n\n      this.visitNodes(function (node) {\n        node._fireEvent(\"save\", undefined);\n      });\n      return {\n        global: global,\n        borders: this._borders._toJson(),\n        layout: this._root.toJson()\n      };\n    }\n  }, {\n    key: \"getSplitterSize\",\n    value: function getSplitterSize() {\n      var splitterSize = this._attributes.splitterSize;\n\n      if (splitterSize === -1) {\n        // use defaults\n        splitterSize = this._pointerFine ? 8 : 12; // larger for mobile\n      }\n\n      return splitterSize;\n    }\n  }, {\n    key: \"isLegacyOverflowMenu\",\n    value: function isLegacyOverflowMenu() {\n      return this._attributes.legacyOverflowMenu;\n    }\n  }, {\n    key: \"getSplitterExtra\",\n    value: function getSplitterExtra() {\n      return this._attributes.splitterExtra;\n    }\n  }, {\n    key: \"isEnableEdgeDock\",\n    value: function isEnableEdgeDock() {\n      return this._attributes.enableEdgeDock;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_addNode\",\n    value: function _addNode(node) {\n      var id = node.getId();\n\n      if (this._idMap[id] !== undefined) {\n        throw new Error(\"Error: each node must have a unique id, duplicate id:\".concat(node.getId()));\n      }\n\n      if (node.getType() !== \"splitter\") {\n        this._idMap[id] = node;\n      }\n    }\n    /** @internal */\n\n  }, {\n    key: \"_layout\",\n    value: function _layout(rect, metrics) {\n      var _a; // let start = Date.now();\n\n\n      this._borderRects = this._borders._layoutBorder({\n        outer: rect,\n        inner: rect\n      }, metrics);\n      rect = this._borderRects.inner.removeInsets(this._getAttribute(\"marginInsets\"));\n      (_a = this._root) === null || _a === void 0 ? void 0 : _a.calcMinSize();\n\n      this._root._layout(rect, metrics); // console.log(\"layout time: \" + (Date.now() - start));\n\n\n      return rect;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_findDropTargetNode\",\n    value: function _findDropTargetNode(dragNode, x, y) {\n      var node = this._root._findDropTargetNode(dragNode, x, y);\n\n      if (node === undefined) {\n        node = this._borders._findDropTargetNode(dragNode, x, y);\n      }\n\n      return node;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_tidy\",\n    value: function _tidy() {\n      // console.log(\"before _tidy\", this.toString());\n      this._root._tidy(); // console.log(\"after _tidy\", this.toString());\n\n    }\n    /** @internal */\n\n  }, {\n    key: \"_updateAttrs\",\n    value: function _updateAttrs(json) {\n      Model._attributeDefinitions.update(json, this._attributes);\n    }\n    /** @internal */\n\n  }, {\n    key: \"_nextUniqueId\",\n    value: function _nextUniqueId() {\n      return '#' + getUUID();\n    }\n    /** @internal */\n\n  }, {\n    key: \"_getAttribute\",\n    value: function _getAttribute(name) {\n      return this._attributes[name];\n    }\n    /**\n     * Sets a function to allow/deny dropping a node\n     * @param onAllowDrop function that takes the drag node and DropInfo and returns true if the drop is allowed\n     */\n\n  }, {\n    key: \"setOnAllowDrop\",\n    value: function setOnAllowDrop(onAllowDrop) {\n      this._onAllowDrop = onAllowDrop;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_getOnAllowDrop\",\n    value: function _getOnAllowDrop() {\n      return this._onAllowDrop;\n    }\n    /**\n     * set callback called when a new TabSet is created.\n     * The tabNode can be undefined if it's the auto created first tabset in the root row (when the last\n     * tab is deleted, the root tabset can be recreated)\n     * @param onCreateTabSet\n     */\n\n  }, {\n    key: \"setOnCreateTabSet\",\n    value: function setOnCreateTabSet(onCreateTabSet) {\n      this._onCreateTabSet = onCreateTabSet;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_getOnCreateTabSet\",\n    value: function _getOnCreateTabSet() {\n      return this._onCreateTabSet;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return JSON.stringify(this.toJson());\n    }\n  }], [{\n    key: \"fromJson\",\n    value: function fromJson(json) {\n      var model = new Model();\n\n      Model._attributeDefinitions.fromJson(json.global, model._attributes);\n\n      if (json.borders) {\n        model._borders = BorderSet._fromJson(json.borders, model);\n      }\n\n      model._root = RowNode._fromJson(json.layout, model);\n\n      model._tidy(); // initial tidy of node tree\n\n\n      return model;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_createAttributeDefinitions\",\n    value: function _createAttributeDefinitions() {\n      var attributeDefinitions = new AttributeDefinitions();\n      attributeDefinitions.add(\"legacyOverflowMenu\", false).setType(Attribute.BOOLEAN); // splitter\n\n      attributeDefinitions.add(\"splitterSize\", -1).setType(Attribute.NUMBER);\n      attributeDefinitions.add(\"splitterExtra\", 0).setType(Attribute.NUMBER);\n      attributeDefinitions.add(\"enableEdgeDock\", true).setType(Attribute.BOOLEAN);\n      attributeDefinitions.add(\"rootOrientationVertical\", false).setType(Attribute.BOOLEAN);\n      attributeDefinitions.add(\"marginInsets\", {\n        top: 0,\n        right: 0,\n        bottom: 0,\n        left: 0\n      }).setType(\"IInsets\");\n      attributeDefinitions.add(\"enableUseVisibility\", false).setType(Attribute.BOOLEAN); // tab\n\n      attributeDefinitions.add(\"tabEnableClose\", true).setType(Attribute.BOOLEAN);\n      attributeDefinitions.add(\"tabCloseType\", 1).setType(\"ICloseType\");\n      attributeDefinitions.add(\"tabEnableFloat\", false).setType(Attribute.BOOLEAN);\n      attributeDefinitions.add(\"tabEnableDrag\", true).setType(Attribute.BOOLEAN);\n      attributeDefinitions.add(\"tabEnableRename\", true).setType(Attribute.BOOLEAN);\n      attributeDefinitions.add(\"tabClassName\", undefined).setType(Attribute.STRING);\n      attributeDefinitions.add(\"tabIcon\", undefined).setType(Attribute.STRING);\n      attributeDefinitions.add(\"tabEnableRenderOnDemand\", true).setType(Attribute.BOOLEAN);\n      attributeDefinitions.add(\"tabDragSpeed\", 0.3).setType(Attribute.NUMBER);\n      attributeDefinitions.add(\"tabBorderWidth\", -1).setType(Attribute.NUMBER);\n      attributeDefinitions.add(\"tabBorderHeight\", -1).setType(Attribute.NUMBER); // tabset\n\n      attributeDefinitions.add(\"tabSetEnableDeleteWhenEmpty\", true).setType(Attribute.BOOLEAN);\n      attributeDefinitions.add(\"tabSetEnableDrop\", true).setType(Attribute.BOOLEAN);\n      attributeDefinitions.add(\"tabSetEnableDrag\", true).setType(Attribute.BOOLEAN);\n      attributeDefinitions.add(\"tabSetEnableDivide\", true).setType(Attribute.BOOLEAN);\n      attributeDefinitions.add(\"tabSetEnableMaximize\", true).setType(Attribute.BOOLEAN);\n      attributeDefinitions.add(\"tabSetEnableClose\", false).setType(Attribute.BOOLEAN);\n      attributeDefinitions.add(\"tabSetAutoSelectTab\", true).setType(Attribute.BOOLEAN);\n      attributeDefinitions.add(\"tabSetClassNameTabStrip\", undefined).setType(Attribute.STRING);\n      attributeDefinitions.add(\"tabSetClassNameHeader\", undefined).setType(Attribute.STRING);\n      attributeDefinitions.add(\"tabSetEnableTabStrip\", true).setType(Attribute.BOOLEAN);\n      attributeDefinitions.add(\"tabSetHeaderHeight\", 0).setType(Attribute.NUMBER);\n      attributeDefinitions.add(\"tabSetTabStripHeight\", 0).setType(Attribute.NUMBER);\n      attributeDefinitions.add(\"tabSetMarginInsets\", {\n        top: 0,\n        right: 0,\n        bottom: 0,\n        left: 0\n      }).setType(\"IInsets\");\n      attributeDefinitions.add(\"tabSetBorderInsets\", {\n        top: 0,\n        right: 0,\n        bottom: 0,\n        left: 0\n      }).setType(\"IInsets\");\n      attributeDefinitions.add(\"tabSetTabLocation\", \"top\").setType(\"ITabLocation\");\n      attributeDefinitions.add(\"tabSetMinWidth\", 0).setType(Attribute.NUMBER);\n      attributeDefinitions.add(\"tabSetMinHeight\", 0).setType(Attribute.NUMBER); // border\n\n      attributeDefinitions.add(\"borderSize\", 200).setType(Attribute.NUMBER);\n      attributeDefinitions.add(\"borderMinSize\", 0).setType(Attribute.NUMBER);\n      attributeDefinitions.add(\"borderBarSize\", 0).setType(Attribute.NUMBER);\n      attributeDefinitions.add(\"borderEnableDrop\", true).setType(Attribute.BOOLEAN);\n      attributeDefinitions.add(\"borderAutoSelectTabWhenOpen\", true).setType(Attribute.BOOLEAN);\n      attributeDefinitions.add(\"borderAutoSelectTabWhenClosed\", false).setType(Attribute.BOOLEAN);\n      attributeDefinitions.add(\"borderClassName\", undefined).setType(Attribute.STRING);\n      attributeDefinitions.add(\"borderEnableAutoHide\", false).setType(Attribute.BOOLEAN);\n      return attributeDefinitions;\n    }\n  }, {\n    key: \"toTypescriptInterfaces\",\n    value: function toTypescriptInterfaces() {\n      console.log(Model._attributeDefinitions.toTypescriptInterface(\"Global\", undefined));\n      console.log(RowNode.getAttributeDefinitions().toTypescriptInterface(\"Row\", Model._attributeDefinitions));\n      console.log(TabSetNode.getAttributeDefinitions().toTypescriptInterface(\"TabSet\", Model._attributeDefinitions));\n      console.log(TabNode.getAttributeDefinitions().toTypescriptInterface(\"Tab\", Model._attributeDefinitions));\n      console.log(BorderNode.getAttributeDefinitions().toTypescriptInterface(\"Border\", Model._attributeDefinitions));\n    }\n  }]);\n\n  return Model;\n}();\n/** @internal */\n\nModel._attributeDefinitions = Model._createAttributeDefinitions();","map":null,"metadata":{},"sourceType":"module"}