{"ast":null,"code":"import _classCallCheck from \"/Users/gustavolopez/Documents/Personal GLR/Curso Desafio Latam/MOD REACT 7 ROUTER 2/poke-api router gelr/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/gustavolopez/Documents/Personal GLR/Curso Desafio Latam/MOD REACT 7 ROUTER 2/poke-api router gelr/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/gustavolopez/Documents/Personal GLR/Curso Desafio Latam/MOD REACT 7 ROUTER 2/poke-api router gelr/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/gustavolopez/Documents/Personal GLR/Curso Desafio Latam/MOD REACT 7 ROUTER 2/poke-api router gelr/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/gustavolopez/Documents/Personal GLR/Curso Desafio Latam/MOD REACT 7 ROUTER 2/poke-api router gelr/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _assertThisInitialized from \"/Users/gustavolopez/Documents/Personal GLR/Curso Desafio Latam/MOD REACT 7 ROUTER 2/poke-api router gelr/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport { Attribute } from \"../Attribute\";\nimport { AttributeDefinitions } from \"../AttributeDefinitions\";\nimport { DockLocation } from \"../DockLocation\";\nimport { DropInfo } from \"../DropInfo\";\nimport { Orientation } from \"../Orientation\";\nimport { Rect } from \"../Rect\";\nimport { CLASSES } from \"../Types\";\nimport { BorderNode } from \"./BorderNode\";\nimport { Node } from \"./Node\";\nimport { RowNode } from \"./RowNode\";\nimport { TabNode } from \"./TabNode\";\nimport { adjustSelectedIndex } from \"./Utils\";\nexport var TabSetNode = /*#__PURE__*/function (_Node) {\n  _inherits(TabSetNode, _Node);\n\n  /** @internal */\n  function TabSetNode(model, json) {\n    var _this;\n\n    _classCallCheck(this, TabSetNode);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(TabSetNode).call(this, model));\n\n    TabSetNode._attributeDefinitions.fromJson(json, _this._attributes);\n\n    model._addNode(_assertThisInitialized(_assertThisInitialized(_this)));\n\n    _this._calculatedTabBarHeight = 0;\n    _this._calculatedHeaderBarHeight = 0;\n    return _this;\n  }\n  /** @internal */\n\n\n  _createClass(TabSetNode, [{\n    key: \"getName\",\n    value: function getName() {\n      return this._getAttr(\"name\");\n    }\n  }, {\n    key: \"getSelected\",\n    value: function getSelected() {\n      var selected = this._attributes.selected;\n\n      if (selected !== undefined) {\n        return selected;\n      }\n\n      return -1;\n    }\n  }, {\n    key: \"getSelectedNode\",\n    value: function getSelectedNode() {\n      var selected = this.getSelected();\n\n      if (selected !== -1) {\n        return this._children[selected];\n      }\n\n      return undefined;\n    }\n  }, {\n    key: \"getWeight\",\n    value: function getWeight() {\n      return this._getAttr(\"weight\");\n    }\n  }, {\n    key: \"getWidth\",\n    value: function getWidth() {\n      return this._getAttr(\"width\");\n    }\n  }, {\n    key: \"getMinWidth\",\n    value: function getMinWidth() {\n      return this._getAttr(\"minWidth\");\n    }\n  }, {\n    key: \"getHeight\",\n    value: function getHeight() {\n      return this._getAttr(\"height\");\n    }\n  }, {\n    key: \"getMinHeight\",\n    value: function getMinHeight() {\n      return this._getAttr(\"minHeight\");\n    }\n    /** @internal */\n\n  }, {\n    key: \"getMinSize\",\n    value: function getMinSize(orientation) {\n      if (orientation === Orientation.HORZ) {\n        return this.getMinWidth();\n      } else {\n        return this.getMinHeight();\n      }\n    }\n    /**\n     * Returns the config attribute that can be used to store node specific data that\n     * WILL be saved to the json. The config attribute should be changed via the action Actions.updateNodeAttributes rather\n     * than directly, for example:\n     * this.state.model.doAction(\n     *   FlexLayout.Actions.updateNodeAttributes(node.getId(), {config:myConfigObject}));\n     */\n\n  }, {\n    key: \"getConfig\",\n    value: function getConfig() {\n      return this._attributes.config;\n    }\n  }, {\n    key: \"isMaximized\",\n    value: function isMaximized() {\n      return this._model.getMaximizedTabset() === this;\n    }\n  }, {\n    key: \"isActive\",\n    value: function isActive() {\n      return this._model.getActiveTabset() === this;\n    }\n  }, {\n    key: \"isEnableDeleteWhenEmpty\",\n    value: function isEnableDeleteWhenEmpty() {\n      return this._getAttr(\"enableDeleteWhenEmpty\");\n    }\n  }, {\n    key: \"isEnableDrop\",\n    value: function isEnableDrop() {\n      return this._getAttr(\"enableDrop\");\n    }\n  }, {\n    key: \"isEnableDrag\",\n    value: function isEnableDrag() {\n      return this._getAttr(\"enableDrag\");\n    }\n  }, {\n    key: \"isEnableDivide\",\n    value: function isEnableDivide() {\n      return this._getAttr(\"enableDivide\");\n    }\n  }, {\n    key: \"isEnableMaximize\",\n    value: function isEnableMaximize() {\n      return this._getAttr(\"enableMaximize\");\n    }\n  }, {\n    key: \"isEnableClose\",\n    value: function isEnableClose() {\n      return this._getAttr(\"enableClose\");\n    }\n  }, {\n    key: \"canMaximize\",\n    value: function canMaximize() {\n      if (this.isEnableMaximize()) {\n        // always allow maximize toggle if already maximized\n        if (this.getModel().getMaximizedTabset() === this) {\n          return true;\n        } // only one tabset, so disable\n\n\n        if (this.getParent() === this.getModel().getRoot() && this.getModel().getRoot().getChildren().length === 1) {\n          return false;\n        }\n\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"isEnableTabStrip\",\n    value: function isEnableTabStrip() {\n      return this._getAttr(\"enableTabStrip\");\n    }\n  }, {\n    key: \"isAutoSelectTab\",\n    value: function isAutoSelectTab() {\n      return this._getAttr(\"autoSelectTab\");\n    }\n  }, {\n    key: \"getClassNameTabStrip\",\n    value: function getClassNameTabStrip() {\n      return this._getAttr(\"classNameTabStrip\");\n    }\n  }, {\n    key: \"getClassNameHeader\",\n    value: function getClassNameHeader() {\n      return this._getAttr(\"classNameHeader\");\n    }\n    /** @internal */\n\n  }, {\n    key: \"calculateHeaderBarHeight\",\n    value: function calculateHeaderBarHeight(metrics) {\n      var headerBarHeight = this._getAttr(\"headerHeight\");\n\n      if (headerBarHeight !== 0) {\n        // its defined\n        this._calculatedHeaderBarHeight = headerBarHeight;\n      } else {\n        this._calculatedHeaderBarHeight = metrics.headerBarSize;\n      }\n    }\n    /** @internal */\n\n  }, {\n    key: \"calculateTabBarHeight\",\n    value: function calculateTabBarHeight(metrics) {\n      var tabBarHeight = this._getAttr(\"tabStripHeight\");\n\n      if (tabBarHeight !== 0) {\n        // its defined\n        this._calculatedTabBarHeight = tabBarHeight;\n      } else {\n        this._calculatedTabBarHeight = metrics.tabBarSize;\n      }\n    }\n  }, {\n    key: \"getHeaderHeight\",\n    value: function getHeaderHeight() {\n      return this._calculatedHeaderBarHeight;\n    }\n  }, {\n    key: \"getTabStripHeight\",\n    value: function getTabStripHeight() {\n      return this._calculatedTabBarHeight;\n    }\n  }, {\n    key: \"getTabLocation\",\n    value: function getTabLocation() {\n      return this._getAttr(\"tabLocation\");\n    }\n    /** @internal */\n\n  }, {\n    key: \"_setWeight\",\n    value: function _setWeight(weight) {\n      this._attributes.weight = weight;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_setSelected\",\n    value: function _setSelected(index) {\n      this._attributes.selected = index;\n    }\n    /** @internal */\n\n  }, {\n    key: \"canDrop\",\n    value: function canDrop(dragNode, x, y) {\n      var dropInfo;\n\n      if (dragNode === this) {\n        var dockLocation = DockLocation.CENTER;\n        var outlineRect = this._tabHeaderRect;\n        dropInfo = new DropInfo(this, outlineRect, dockLocation, -1, CLASSES.FLEXLAYOUT__OUTLINE_RECT);\n      } else if (this._contentRect.contains(x, y)) {\n        var _dockLocation = DockLocation.CENTER;\n\n        if (this._model.getMaximizedTabset() === undefined) {\n          _dockLocation = DockLocation.getLocation(this._contentRect, x, y);\n        }\n\n        var _outlineRect = _dockLocation.getDockRect(this._rect);\n\n        dropInfo = new DropInfo(this, _outlineRect, _dockLocation, -1, CLASSES.FLEXLAYOUT__OUTLINE_RECT);\n      } else if (this._tabHeaderRect != null && this._tabHeaderRect.contains(x, y)) {\n        var r;\n        var yy;\n        var h;\n\n        if (this._children.length === 0) {\n          r = this._tabHeaderRect.clone();\n          yy = r.y + 3;\n          h = r.height - 4;\n          r.width = 2;\n        } else {\n          var child = this._children[0];\n          r = child.getTabRect();\n          yy = r.y;\n          h = r.height;\n          var p = this._tabHeaderRect.x;\n          var childCenter = 0;\n\n          for (var i = 0; i < this._children.length; i++) {\n            child = this._children[i];\n            r = child.getTabRect();\n            childCenter = r.x + r.width / 2;\n\n            if (x >= p && x < childCenter) {\n              var _dockLocation2 = DockLocation.CENTER;\n\n              var _outlineRect2 = new Rect(r.x - 2, yy, 3, h);\n\n              dropInfo = new DropInfo(this, _outlineRect2, _dockLocation2, i, CLASSES.FLEXLAYOUT__OUTLINE_RECT);\n              break;\n            }\n\n            p = childCenter;\n          }\n        }\n\n        if (dropInfo == null) {\n          var _dockLocation3 = DockLocation.CENTER;\n\n          var _outlineRect3 = new Rect(r.getRight() - 2, yy, 3, h);\n\n          dropInfo = new DropInfo(this, _outlineRect3, _dockLocation3, this._children.length, CLASSES.FLEXLAYOUT__OUTLINE_RECT);\n        }\n      }\n\n      if (!dragNode._canDockInto(dragNode, dropInfo)) {\n        return undefined;\n      }\n\n      return dropInfo;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_layout\",\n    value: function _layout(rect, metrics) {\n      this.calculateHeaderBarHeight(metrics);\n      this.calculateTabBarHeight(metrics);\n\n      if (this.isMaximized()) {\n        rect = this._model.getRoot().getRect();\n      }\n\n      rect = rect.removeInsets(this._getAttr(\"marginInsets\"));\n      this._rect = rect;\n      rect = rect.removeInsets(this._getAttr(\"borderInsets\"));\n      var showHeader = this.getName() !== undefined;\n      var y = 0;\n      var h = 0;\n\n      if (showHeader) {\n        y += this._calculatedHeaderBarHeight;\n        h += this._calculatedHeaderBarHeight;\n      }\n\n      if (this.isEnableTabStrip()) {\n        if (this.getTabLocation() === \"top\") {\n          this._tabHeaderRect = new Rect(rect.x, rect.y + y, rect.width, this._calculatedTabBarHeight);\n        } else {\n          this._tabHeaderRect = new Rect(rect.x, rect.y + rect.height - this._calculatedTabBarHeight, rect.width, this._calculatedTabBarHeight);\n        }\n\n        h += this._calculatedTabBarHeight;\n\n        if (this.getTabLocation() === \"top\") {\n          y += this._calculatedTabBarHeight;\n        }\n      }\n\n      this._contentRect = new Rect(rect.x, rect.y + y, rect.width, rect.height - h);\n\n      for (var i = 0; i < this._children.length; i++) {\n        var child = this._children[i];\n\n        child._layout(this._contentRect, metrics);\n\n        child._setVisible(i === this.getSelected());\n      }\n    }\n    /** @internal */\n\n  }, {\n    key: \"_delete\",\n    value: function _delete() {\n      this._parent._removeChild(this);\n    }\n    /** @internal */\n\n  }, {\n    key: \"_remove\",\n    value: function _remove(node) {\n      var removedIndex = this._removeChild(node);\n\n      this._model._tidy();\n\n      adjustSelectedIndex(this, removedIndex);\n    }\n    /** @internal */\n\n  }, {\n    key: \"drop\",\n    value: function drop(dragNode, location, index, select) {\n      var dockLocation = location;\n\n      if (this === dragNode) {\n        // tabset drop into itself\n        return; // dock back to itself\n      }\n\n      var dragParent = dragNode.getParent();\n      var fromIndex = 0;\n\n      if (dragParent !== undefined) {\n        fromIndex = dragParent._removeChild(dragNode); // if selected node in border is being docked into tabset then deselect border tabs\n\n        if (dragParent instanceof BorderNode && dragParent.getSelected() === fromIndex) {\n          dragParent._setSelected(-1);\n        } else {\n          adjustSelectedIndex(dragParent, fromIndex);\n        }\n      } // if dropping a tab back to same tabset and moving to forward position then reduce insertion index\n\n\n      if (dragNode.getType() === TabNode.TYPE && dragParent === this && fromIndex < index && index > 0) {\n        index--;\n      } // simple_bundled dock to existing tabset\n\n\n      if (dockLocation === DockLocation.CENTER) {\n        var insertPos = index;\n\n        if (insertPos === -1) {\n          insertPos = this._children.length;\n        }\n\n        if (dragNode.getType() === TabNode.TYPE) {\n          this._addChild(dragNode, insertPos);\n\n          if (select || select !== false && this.isAutoSelectTab()) {\n            this._setSelected(insertPos);\n          } // console.log(\"added child at : \" + insertPos);\n\n        } else {\n          for (var i = 0; i < dragNode.getChildren().length; i++) {\n            var child = dragNode.getChildren()[i];\n\n            this._addChild(child, insertPos); // console.log(\"added child at : \" + insertPos);\n\n\n            insertPos++;\n          }\n        }\n\n        this._model._setActiveTabset(this);\n      } else {\n        var tabSet;\n\n        if (dragNode instanceof TabNode) {\n          // create new tabset parent\n          // console.log(\"create a new tabset\");\n          var callback = this._model._getOnCreateTabSet();\n\n          tabSet = new TabSetNode(this._model, callback ? callback(dragNode) : {});\n\n          tabSet._addChild(dragNode); // console.log(\"added child at end\");\n\n\n          dragParent = tabSet;\n        } else {\n          tabSet = dragNode;\n        }\n\n        var parentRow = this._parent;\n        var pos = parentRow.getChildren().indexOf(this);\n\n        if (parentRow.getOrientation() === dockLocation._orientation) {\n          tabSet._setWeight(this.getWeight() / 2);\n\n          this._setWeight(this.getWeight() / 2); // console.log(\"added child 50% size at: \" +  pos + dockLocation.indexPlus);\n\n\n          parentRow._addChild(tabSet, pos + dockLocation._indexPlus);\n        } else {\n          // create a new row to host the new tabset (it will go in the opposite direction)\n          // console.log(\"create a new row\");\n          var newRow = new RowNode(this._model, {});\n\n          newRow._setWeight(this.getWeight());\n\n          newRow._addChild(this);\n\n          this._setWeight(50);\n\n          tabSet._setWeight(50); // console.log(\"added child 50% size at: \" +  dockLocation.indexPlus);\n\n\n          newRow._addChild(tabSet, dockLocation._indexPlus);\n\n          parentRow._removeChild(this);\n\n          parentRow._addChild(newRow, pos);\n        }\n\n        this._model._setActiveTabset(tabSet);\n      }\n\n      this._model._tidy();\n    }\n  }, {\n    key: \"toJson\",\n    value: function toJson() {\n      var json = {};\n\n      TabSetNode._attributeDefinitions.toJson(json, this._attributes);\n\n      json.children = this._children.map(function (child) {\n        return child.toJson();\n      });\n\n      if (this.isActive()) {\n        json.active = true;\n      }\n\n      if (this.isMaximized()) {\n        json.maximized = true;\n      }\n\n      return json;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_updateAttrs\",\n    value: function _updateAttrs(json) {\n      TabSetNode._attributeDefinitions.update(json, this._attributes);\n    }\n    /** @internal */\n\n  }, {\n    key: \"_getAttributeDefinitions\",\n    value: function _getAttributeDefinitions() {\n      return TabSetNode._attributeDefinitions;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_getPrefSize\",\n    value: function _getPrefSize(orientation) {\n      var prefSize = this.getWidth();\n\n      if (orientation === Orientation.VERT) {\n        prefSize = this.getHeight();\n      }\n\n      return prefSize;\n    }\n    /** @internal */\n\n  }], [{\n    key: \"_fromJson\",\n    value: function _fromJson(json, model) {\n      var newLayoutNode = new TabSetNode(model, json);\n\n      if (json.children != null) {\n        var _iterator = _createForOfIteratorHelper(json.children),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var jsonChild = _step.value;\n\n            var child = TabNode._fromJson(jsonChild, model);\n\n            newLayoutNode._addChild(child);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n\n      if (newLayoutNode._children.length === 0) {\n        newLayoutNode._setSelected(-1);\n      }\n\n      if (json.maximized && json.maximized === true) {\n        model._setMaximizedTabset(newLayoutNode);\n      }\n\n      if (json.active && json.active === true) {\n        model._setActiveTabset(newLayoutNode);\n      }\n\n      return newLayoutNode;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_createAttributeDefinitions\",\n    value: function _createAttributeDefinitions() {\n      var attributeDefinitions = new AttributeDefinitions();\n      attributeDefinitions.add(\"type\", TabSetNode.TYPE, true).setType(Attribute.STRING).setFixed();\n      attributeDefinitions.add(\"id\", undefined).setType(Attribute.STRING);\n      attributeDefinitions.add(\"weight\", 100).setType(Attribute.NUMBER);\n      attributeDefinitions.add(\"width\", undefined).setType(Attribute.NUMBER);\n      attributeDefinitions.add(\"height\", undefined).setType(Attribute.NUMBER);\n      attributeDefinitions.add(\"selected\", 0).setType(Attribute.NUMBER);\n      attributeDefinitions.add(\"name\", undefined).setType(Attribute.STRING);\n      attributeDefinitions.add(\"config\", undefined).setType(\"any\");\n      attributeDefinitions.addInherited(\"enableDeleteWhenEmpty\", \"tabSetEnableDeleteWhenEmpty\");\n      attributeDefinitions.addInherited(\"enableDrop\", \"tabSetEnableDrop\");\n      attributeDefinitions.addInherited(\"enableDrag\", \"tabSetEnableDrag\");\n      attributeDefinitions.addInherited(\"enableDivide\", \"tabSetEnableDivide\");\n      attributeDefinitions.addInherited(\"enableMaximize\", \"tabSetEnableMaximize\");\n      attributeDefinitions.addInherited(\"enableClose\", \"tabSetEnableClose\");\n      attributeDefinitions.addInherited(\"classNameTabStrip\", \"tabSetClassNameTabStrip\");\n      attributeDefinitions.addInherited(\"classNameHeader\", \"tabSetClassNameHeader\");\n      attributeDefinitions.addInherited(\"enableTabStrip\", \"tabSetEnableTabStrip\");\n      attributeDefinitions.addInherited(\"borderInsets\", \"tabSetBorderInsets\");\n      attributeDefinitions.addInherited(\"marginInsets\", \"tabSetMarginInsets\");\n      attributeDefinitions.addInherited(\"minWidth\", \"tabSetMinWidth\");\n      attributeDefinitions.addInherited(\"minHeight\", \"tabSetMinHeight\");\n      attributeDefinitions.addInherited(\"headerHeight\", \"tabSetHeaderHeight\");\n      attributeDefinitions.addInherited(\"tabStripHeight\", \"tabSetTabStripHeight\");\n      attributeDefinitions.addInherited(\"tabLocation\", \"tabSetTabLocation\");\n      attributeDefinitions.addInherited(\"autoSelectTab\", \"tabSetAutoSelectTab\").setType(Attribute.BOOLEAN);\n      return attributeDefinitions;\n    }\n  }, {\n    key: \"getAttributeDefinitions\",\n    value: function getAttributeDefinitions() {\n      return TabSetNode._attributeDefinitions;\n    }\n  }]);\n\n  return TabSetNode;\n}(Node);\nTabSetNode.TYPE = \"tabset\";\n/** @internal */\n\nTabSetNode._attributeDefinitions = TabSetNode._createAttributeDefinitions();","map":null,"metadata":{},"sourceType":"module"}