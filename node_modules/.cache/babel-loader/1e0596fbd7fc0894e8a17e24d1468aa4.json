{"ast":null,"code":"import _slicedToArray from \"/Users/gustavolopez/Documents/Personal GLR/Curso Desafio Latam/MOD REACT 7 ROUTER 2/poke-api router gelr/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport * as React from \"react\";\nimport { Rect } from \"../Rect\";\nimport { TabSetNode } from \"../model/TabSetNode\";\nimport { Orientation } from \"../Orientation\";\n/** @internal */\n\nexport var useTabOverflow = function useTabOverflow(node, orientation, toolbarRef, stickyButtonsRef) {\n  var firstRender = React.useRef(true);\n  var tabsTruncated = React.useRef(false);\n  var lastRect = React.useRef(new Rect(0, 0, 0, 0));\n  var selfRef = React.useRef(null);\n\n  var _React$useState = React.useState(0),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      position = _React$useState2[0],\n      setPosition = _React$useState2[1];\n\n  var userControlledLeft = React.useRef(false);\n\n  var _React$useState3 = React.useState([]),\n      _React$useState4 = _slicedToArray(_React$useState3, 2),\n      hiddenTabs = _React$useState4[0],\n      setHiddenTabs = _React$useState4[1];\n\n  var lastHiddenCount = React.useRef(0); // if selected node or tabset/border rectangle change then unset usercontrolled (so selected tab will be kept in view)\n\n  React.useLayoutEffect(function () {\n    userControlledLeft.current = false;\n  }, [node.getSelectedNode(), node.getRect().width, node.getRect().height]);\n  React.useLayoutEffect(function () {\n    updateVisibleTabs();\n  });\n  React.useEffect(function () {\n    var instance = selfRef.current;\n    instance.addEventListener('wheel', onWheel, {\n      passive: false\n    });\n    return function () {\n      instance.removeEventListener('wheel', onWheel);\n    };\n  }, []); // needed to prevent default mouse wheel over tabset/border (cannot do with react event?)\n\n  var onWheel = function onWheel(event) {\n    event.preventDefault();\n  };\n\n  var getNear = function getNear(rect) {\n    if (orientation === Orientation.HORZ) {\n      return rect.x;\n    } else {\n      return rect.y;\n    }\n  };\n\n  var getFar = function getFar(rect) {\n    if (orientation === Orientation.HORZ) {\n      return rect.getRight();\n    } else {\n      return rect.getBottom();\n    }\n  };\n\n  var getSize = function getSize(rect) {\n    if (orientation === Orientation.HORZ) {\n      return rect.width;\n    } else {\n      return rect.height;\n    }\n  };\n\n  var updateVisibleTabs = function updateVisibleTabs() {\n    var tabMargin = 2;\n\n    if (firstRender.current === true) {\n      tabsTruncated.current = false;\n    }\n\n    var nodeRect = node instanceof TabSetNode ? node.getRect() : node.getTabHeaderRect();\n    var lastChild = node.getChildren()[node.getChildren().length - 1];\n    var stickyButtonsSize = stickyButtonsRef.current === null ? 0 : getSize(stickyButtonsRef.current.getBoundingClientRect());\n\n    if (firstRender.current === true || lastHiddenCount.current === 0 && hiddenTabs.length !== 0 || nodeRect.width !== lastRect.current.width || // incase rect changed between first render and second\n    nodeRect.height !== lastRect.current.height) {\n      lastHiddenCount.current = hiddenTabs.length;\n      lastRect.current = nodeRect;\n      var enabled = node instanceof TabSetNode ? node.isEnableTabStrip() === true : true;\n      var endPos = getFar(nodeRect) - stickyButtonsSize;\n\n      if (toolbarRef.current !== null) {\n        endPos -= getSize(toolbarRef.current.getBoundingClientRect());\n      }\n\n      if (enabled && node.getChildren().length > 0) {\n        if (hiddenTabs.length === 0 && position === 0 && getFar(lastChild.getTabRect()) + tabMargin < endPos) {\n          return; // nothing to do all tabs are shown in available space\n        }\n\n        var shiftPos = 0;\n        var selectedTab = node.getSelectedNode();\n\n        if (selectedTab && !userControlledLeft.current) {\n          var selectedRect = selectedTab.getTabRect();\n          var selectedStart = getNear(selectedRect) - tabMargin;\n          var selectedEnd = getFar(selectedRect) + tabMargin; // when selected tab is larger than available space then align left\n\n          if (getSize(selectedRect) + 2 * tabMargin >= endPos - getNear(nodeRect)) {\n            shiftPos = getNear(nodeRect) - selectedStart;\n          } else {\n            if (selectedEnd > endPos || selectedStart < getNear(nodeRect)) {\n              if (selectedStart < getNear(nodeRect)) {\n                shiftPos = getNear(nodeRect) - selectedStart;\n              } // use second if statement to prevent tab moving back then forwards if not enough space for single tab\n\n\n              if (selectedEnd + shiftPos > endPos) {\n                shiftPos = endPos - selectedEnd;\n              }\n            }\n          }\n        }\n\n        var extraSpace = Math.max(0, endPos - (getFar(lastChild.getTabRect()) + tabMargin + shiftPos));\n        var newPosition = Math.min(0, position + shiftPos + extraSpace); // find hidden tabs\n\n        var diff = newPosition - position;\n        var hidden = [];\n\n        for (var i = 0; i < node.getChildren().length; i++) {\n          var child = node.getChildren()[i];\n\n          if (getNear(child.getTabRect()) + diff < getNear(nodeRect) || getFar(child.getTabRect()) + diff > endPos) {\n            hidden.push({\n              node: child,\n              index: i\n            });\n          }\n        }\n\n        if (hidden.length > 0) {\n          tabsTruncated.current = true;\n        }\n\n        firstRender.current = false; // need to do a second render\n\n        setHiddenTabs(hidden);\n        setPosition(newPosition);\n      }\n    } else {\n      firstRender.current = true;\n    }\n  };\n\n  var onMouseWheel = function onMouseWheel(event) {\n    var delta = 0;\n\n    if (Math.abs(event.deltaX) > Math.abs(event.deltaY)) {\n      delta = -event.deltaX;\n    } else {\n      delta = -event.deltaY;\n    }\n\n    if (event.deltaMode === 1) {\n      // DOM_DELTA_LINE\t0x01\tThe delta values are specified in lines.\n      delta *= 40;\n    }\n\n    setPosition(position + delta);\n    userControlledLeft.current = true;\n    event.stopPropagation();\n  };\n\n  return {\n    selfRef: selfRef,\n    position: position,\n    userControlledLeft: userControlledLeft,\n    hiddenTabs: hiddenTabs,\n    onMouseWheel: onMouseWheel,\n    tabsTruncated: tabsTruncated.current\n  };\n};","map":null,"metadata":{},"sourceType":"module"}